# 알고리즘 1주차 문제풀이



## 1일차 - 알고리즘 개요

- 백준 - 알파벳 찾기 (no.10809)
- 





## 3일차 - Stack

- 유효한 괄호 (no.20)

```python
## 파이썬 언어로 Stack을 사용할 때는 그냥 리스트를 사용해도 된다
## push대신 append를 사용하고 pop은 그대로 사용하면 된다 셋 다 O(1)이다

## 코딩테스트 - 유효한 괄호 (no.20)
    def is_valid(self, s: str) -> bool:
        ## json형식을 사용하여 서로 맞는 괄호끼리 짝지운다
        pair = {
            '}': '{',
            ')': '(',
            ']': '[',
        }
        opener = "({["
        stack = []

        for char in s:
            ## 파이썬에서 char이 문자열 내에 있는지 확인하는 방법
            if char in opener:
                ## 오프너 ({[ 이면 리스트에 append한다 - stack의 push
                stack.append(char)
            else:
                ## 오프너가 아니어서 pop을 하는데 stack에 아무것도 없다면 잘못된 input - EX) '[}()]'
                if not stack:
                    return False
                ## )}]를 꺼냈을 때 pair가 맞는지 확인 - EX) '({)}' 같은 input을 거를 수 있음
                top = stack.pop()
                if pair[char] != top:
                    return False
        ## stack에 아무것도 없으면 True이므로 not stack을 한다
        return not stack
```



## 4일차 - Queue

- 백준 - 카드2 (no.2164)

```python
from collections import deque

    def test_problem_queue(num:int) -> int:
        ## 내장함수 queue를 사용한다 ==> deque
        ## deque는 append와 appendleft, pop과 popleft가 모두 빠르고 간결해서 queue는 deque를 사용한다
        card = deque([i for i in range(1, num+1)])
        while len(card) > 1:
            ## 제일 위 카드 바닥에 버림
            card.popleft()
            ## 다음 제일 위 카드를 카드뭉치 제일 아래로 옮김
            card.append(card.popleft())
        return card.popleft()
```



- 큐를 이용한 스택 구현 (leetcode no.225)

```python
    class MyStack:
        def __init__(self):
            self.q = collections.deque()

        def push(self, x: int) -> None:
            self.q.append(x)
            ## 요소 삽입 후 맨 앞에 두는 상태로 재정렬
            ## _는 index가 필요없을때 사용한다
            ## element의 개수가 10개라면 9개만 옮기면 되므로 len(self.q)-1 을 사용한다
            ## deque에서 append는 오른쪽에 삽입이라고 생각하면 쉽다
            for _ in range(len(self.q)-1):
                self.q.append(self.q.popleft())

        def pop(self) -> int:
            return self.q.popleft()

        def top(self) -> int:
            return self.q[0]

        def empty(self) -> bool:
            return len(self.q) == 0
```

- 스택을 이용한 큐 구현 (leetcode no.232)

```python
    class MyQueue:
        def __init__(self):
            ## 배열이용 구현
            self.input = []
            self.output = []

        def push(self, val):
            self.input.append(val)

        def peek(self):
            if not self.output:
                while self.input:
                    self.output.append(self.input.pop())
            return self.output[-1]

        def pop(self):
            self.peek()
            return self.output.pop()

        def is_empty(self):
            return not (self.input or self.output)
```



- 원형 큐 디자인 (leetcode no.622)

```python
    class MyCircularQueue:
        ## 배열을 이용하여 구현한다
        ## p2(rear 포인터)은 삽입할 때 쓰이고 p1(front 포인터)은 삭제에 사용된다
        def __init__(self, size : int):
            self.q = [None]*size
            self.size = size
            self.p1 = 0
            self.p2 = 0

        def enQueue(self, value) -> bool:
            if self.q[self.p2] is None:
                self.q[self.p2] = value
                self.p2 = (self.p2+1)%self.size
                return True
            return False

            ## 문제 조건 - 삭제만 하는것으로 구현한다
        def deQueue(self):
            if self.q[self.p1] is None:
                return False

            self.q[self.p1] = None
            self.p1 = (self.p1 + 1) % self.size
            return True

        ## 문제 조건 - 비어있으면 -1 아니면 값을 반환한다
        ## return뒤에 삼항연산자로 간단히 값 반환
        def Front(self):
            return -1 if not self.q[self.p1] else self.q[self.p1]

        ## 문제 조건 - 비어있으면 -1 아니면 값을 반환한다
        def Rear(self):
            return -1 if not self.q[self.p2 - 1] else self.q[self.p2 - 1]

        def isEmpty(self) -> bool:
            return self.p1 == self.p2 and self.q[self.p1] is None

        def isFull(self) -> bool:
            return self.p1 == self.p2 and self.q[self.p1] is not None
```


# 3주차 문제풀이 알고리즘



## 1일 차









## 2일 차

- 이진 탐색 (leetcode no.704)

```python
from typing import List


## leetcode no.704
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def rec(ps,pe):
            ## 이진 탐색을 위한 중간index
            half = (ps+pe)//2
            ## 정답을 찾았을 때 반환
            if nums[half] == target:
                return half
            ## index가 시작index과 겹쳤는데도, 위의 조건문이 실행되지 않았다면
            ## 리스트에 타겟번호가 없는 것이다
            elif half==ps:
                return -1
            ## 이진 탐색을 재귀함수로 구현한다
            elif nums[half] > target:
                return rec(ps,half)
            elif nums[half] < target:
                return rec(half,pe)

        return rec(0,len(nums))

sol = Solution()
print(sol.search([-1,0,3,5,9,12],9))
print(sol.search([-1,0,3,5,9,12],2))

## 교재 풀이
def binary_search(nums, target):
    def bs(start, end):
        ## start에 1을 더 하거나, end에 1을 빼서 호출하므로
        ## 마지막까지 찾은 후 start 인덱스가 end보다 더 커지면 값이 없는 것!
        if start > end:
            return -1

        mid = (start + end) // 2

        if nums[mid] < target:
            ## 굳이 찾아본 값의 index를 추가해서 찾지 말자
            return bs(mid + 1, end)
        elif nums[mid] > target:
            ## 굳이 찾아본 값의 index를 추가해서 찾지 말자
            return bs(start, mid - 1)
        else:
            return mid

    ## 처음 재귀함수에 값을 넣을때 실제 index값을 넣으려면 배열의 길이에서 하나를 빼야한다
    return bs(0, len(nums) - 1)

```



- 두 수의 합

```python
from typing import List


## leetcode no.704
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        def rec(ps,pe):
            ## 이진 탐색을 위한 중간index
            half = (ps+pe)//2
            ## 정답을 찾았을 때 반환
            if nums[half] == target:
                return half
            ## index가 시작index과 겹쳤는데도, 위의 조건문이 실행되지 않았다면
            ## 리스트에 타겟번호가 없는 것이다
            elif half==ps:
                return -1
            ## 이진 탐색을 재귀함수로 구현한다
            elif nums[half] > target:
                return rec(ps,half)
            elif nums[half] < target:
                return rec(half,pe)

        return rec(0,len(nums))

sol = Solution()
print(sol.search([-1,0,3,5,9,12],9))
print(sol.search([-1,0,3,5,9,12],2))

## 교재 풀이
def binary_search(nums, target):
    def bs(start, end):
        ## start에 1을 더 하거나, end에 1을 빼서 호출하므로
        ## 마지막까지 찾은 후 start 인덱스가 end보다 더 커지면 값이 없는 것!
        if start > end:
            return -1

        mid = (start + end) // 2

        if nums[mid] < target:
            ## 굳이 찾아본 값의 index를 추가해서 찾지 말자
            return bs(mid + 1, end)
        elif nums[mid] > target:
            ## 굳이 찾아본 값의 index를 추가해서 찾지 말자
            return bs(start, mid - 1)
        else:
            return mid

    ## 처음 재귀함수에 값을 넣을때 실제 index값을 넣으려면 배열의 길이에서 하나를 빼야한다
    return bs(0, len(nums) - 1)
```



- 두 배열의 교집합

```python
import collections
from typing import List


## leetcode no.349
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        dict = collections.defaultdict(int)
        set1 = set(nums2)

        result = []
        for i in nums1:
            dict[i] = 1
        for ele in set1:
            if dict[ele] == 1:
                result.append(ele)
        return result


sol = Solution()
print(sol.intersection([4,9,5], [9,4,9,8,4]))
```



- 회전 정렬된 배열 검색


> 1일 1로그 100일 완성 [브라이언 W.커니핸 지음]

| CS 스터디 [ Computer Science ] |
| ------------------------------ |

> 서론 중
>
> 디지털 세상의 4가지 핵심 아이디어
>
> 1. 정보의 보편적 디지털 표현 - 저수준 디지털 데이터
> 2. 보편화된 디지털 처리 장치 - 작동방식이 동등하여 기계간 융합 및 동기화 진행 중
> 3. 보편화된 디지털 네트워크 - 세계적 인프라 구축
> 4. 어마어마한 양의 디지털 데이터 수집 및 분석



CS 공부는 왜 해야할까

> 알고리즘 시험과 다르게 무조건 보는 기술면접에  CS 지식이 필요함

CS 공부 방법

> 관련 서적, 구글링, 깃허브



# 하드웨어

> 1부에서는 컴퓨터 하드웨어에 관해 설명하며, 컴퓨터 시스템의 논리적 아키텍처에 초점을 준다.
>
> "완성된 장치가 범용 컴퓨팅 기계가 되려면 산술 연산, 기억-저장, 제어, 운영자와의 연결을 담당하는 특정 주요 기관을 포함해야 한다" - 아서 벅스, 허먼 골드스타인, 존 폰 노이만.. 1946



## 001 컴퓨터의 논리와 구조

컴퓨터의  두 가지 측면 - 논리적(기능적) 구성, 물리적 구조

컴퓨터의 종류는 달라도, 내부 작동 원리는 근본적으로 같다 - 추상적인 기능은 바뀌지 않음



## 002 프로세서 속도와 심장 박동수

- 폰 노이만 아키텍처
  - **프로세서**, 명령어와 데이터를 담는 **메모리와 저장 장치**, **입력**과 **출력**장치가 있는 기본구조
- 프로세서 - CPU [ Central Processing Unit ]
- 주 기억 장치 - RAM [ Random Access Memory ]
- 보조 기억 장치 - 디스크, 드라이브



### 프로세서 [ processor ]

> 컴퓨터의 두뇌에 해당한다.
>
> 프로세서는 산술 연산을 하고, 데이터를 여기저기로 옮기며, 다른 구성 요소의 작업을 제어한다.
>
> 컴퓨터 부품 중에서 코어 [ core ]가 프로세서에 해당한다.
>
> 헤르즈 Hz는 1초에 프로세서가 수행하는 연산이라고 보면 된다.



### 주 기억 장치 [ primary memory ]

>컴퓨터가 실행되는 동안 정보를 저장할 장소를 제공한다.
>
>프로세서가 현재 작업 중인 데이터뿐만 아니라 프로세서가 그 데이터로 무엇을 해야 하는지 알려주는 명령어도 저장한다. 메모리에 다른 명령어를 로드(적재)하여 프로세서가 다른 계산을 수행하게 할 수 있다. 이를 **프로그램 내장식** 이라하며, 다양한 작업을 가능하게 해준다.
>
>주 기억 장치를 RAM이라고 부르는 이유는, **프로세서가 정보에 접근할 때 메모리에 저장된 위치와 무관하게 같은 속도로 접근할 수 있기 때문**이다. 대부분의 메모리는 **휘발성 [ volatile ]**이다. 전원이 꺼지면 메모리의 내용이 사라지고 현재 활성화 된 모든 정보가 사라진다는 뜻이다.
>
>메모리 용량에는 어떤 의미가 있을까? 대게 **메모리 용량이 클수록 컴퓨팅 속도가 더 빠르다**고 볼 수 있다. 메모리가 작으면 동시에 여러 프로그램을 실행하기에 용량이 충분하지 않고, 비활성화 된 프로그램의 일부를 옮겨 새로운 작업을 위한 공간을 만드는 데 시간이 걸리기 때문이다.



## 003 HDD와 SSD의 차이



### 보조 기억 장치

> 전원이 꺼져 있을 때도 정보를 유지하는 장치



#### HDD

> 자기 디스크 (하드 디스크, 하드 드라이브)
>
> 회전하는 금속 표면에 있는 자성 물질을 읽어 데이터를 읽는다
>
> 주 기억 장치보다 저렴하지만 속도가 느리다



#### SSD [ Solid State Drive ]

> 회전하는 기계 장치 대신 **플래시 메모리 [ flash memory ]**를 사용한다
>
> 전원이 꺼져 있어도 개별 소자의 전하를 유지하는 회로에 정보가 전하 형태로 저장된다
>
> 저장된 전하를 읽어 값이 무엇인지 확인 할 수 있고, 삭제하고 새 값으로 덮어 쓸 수도 있다
>
> 기존의 디스크 저장 장치보다 더 빠르고 가볍고 안정적이며, 내구성과 전기소모효율이 좋다



#### 추상화

> 컴퓨터의 논리적 구조와 물리적 구현 간에는 차이가 많지만, 소프트웨어는 추상화를 통하여 정보가 물리적으로 저장되는 방법과 무관하게 계층구조로 보이게 만든다
>
> 물리적 구현을 이해하지 못하더라도, 논리적 구조를 사용할 수 있다



#### 다른 장치들

> 실제로 컴퓨터 내부에 여러가지 버스가 있고, 각각 그 기능에 적합한 속성이 있다
>
> 프로세서와 메모리 사이를 연결하는 버스는 짧고 빠르지만 비싼 반면,
> 헤드폰 잭에 연결되는 버스는 길고 느리지만 저렴하다

- 입력
  - 마우스, 키보드, 터치스크린, 마이크, 카메라, 스캐너 등등
- 출력
  - 디스플레이, 프린터, 스피커 등등



## 004 가로세로 1cm 프로세서 칩

> 컴퓨터 부품이 올라가 있는 회로 기판에서는 발전 양상이 명확히 드러난다
> 20년 전 많은 회로, 배선, 연결 핀이 조밀하게 배치된 것과 비교하면, **요즘에는 부품의 수가 더 적다**
>
> 컴퓨터의 전자 회로는 몇 가지 기본 소자가 매우 많이 모여 만들어지는데,
> 가장 중요한 기본 소자로는 논리 게이트 (logic gate)를 들 수 있다
> 논리 게이트는 한 개나 두 개의 입력 값을 바탕으로 단일 출력 값을 계산해 낸다
> 이러한 게이트가 필요한 만큼 적절한 방식으로 연결되면 어떤 종류의 계산도 수행할 수 있다
>
> 논리 게이트는 집적회로 (IC [ Integrated Circuits ])상에서 만들어진다
> 집적회로는 흔히 칩(chip) 또는 마이크로칩(microchip)이라 한다
> 집적회로는 개별 부품과 재래식 전선이 없으며,
> 이 회로를 만들기 위해 복잡한 광학적, 화학적 공정을 거친다
> 따라서 집적회로는 개별 부품으로 만들어진 회로보다 훨씬 작고 견고하다
>
> 회로 소자에서 가장 핵심적인 부분은 트랜지스터 (transistor)이다
> 컴퓨터에서 트랜지스터는 기본적으로 스위치 역할을 한다
> 이 간단한 원리를 이용해서 복잡한 시스템을 만든다



## 005 50년 넘게 유지된 무어의 법칙

> **무어의 법칙**
>
> 고든 무어는 기술이 향상됨에 따라 일정한 크기의 집적회로에 들어갈 수 있는 **트랜지스터의 수**가,
> **매년 대략 두배**가 된다고 관측했다 (후에 2년마다 두배로 수정했다)
>
> 트랜지스터의 수는 컴퓨팅 성능을 간접적으로 나타내는 지표이므로,
> 2년마다 컴퓨팅 성능이 두배가 된다는 것을 의미했다
>
> 무어의 법칙은 거의 60년 동안 계속 진행됐고, 이제 집적회로에는
> **1965년에 비해 100만 배가 훨신 넘는 트랜지스터가** 들어있다
>
> 회로의 규모를 특정짓는 대표적인 척도로는 집적회로의 배선 폭, 즉 회로선폭이 사용되고
> (반도체 업계에서는 이를 피처 크기(feature size) 라고도 한다) 회로선폭은 꾸준히 줄어들어왔다
>
> 펩 라인(fabrication line) - 제조 공정
>
> 무어의 법칙은 자연의 법칙이 아니라 반도체 산업에서 목표설정을 위한 일종의 가이드라인이다
> 현재는 무어의 법칙이 적용되고 있지 않다 (많은 이유 중 하나는 칩의 열관리 때문)
> 대신 장착 가능한 코어의 개수가 늘면서 성능이 향상되고 있다



## 006 요약

> 컴퓨터 하드웨어의 기하급수적인 발전이, 우리의 삶을 바꿔놓은 디지털 혁명의 원인이 되었다
>
> 컴퓨터의 성능과 용량의 증가가 사용자의 변화부터 목적의 변화까지 영향을 끼쳤다
>
> 20세기 **컴퓨터과학의 위대한 통찰** 중 하나는 오늘날의 디지털 컴퓨터와 최초의 PC,  원조컴퓨터, 휴대전화, 스마트 기기, 클라우트 서버의 **논리적 속성 또는 기능적 속성은 모두 같다는 사실**이다



## 007 연속과 불연속

이진 숫자 - 비트(bit)

>컴퓨터가 정보를 표현하는 방식

1. 컴퓨터는 디지털 처리 장치이다
   - 즉, 컴퓨터는 불연속적인 덩어리로 입력받고, 불연속적인 값을 갖는 정보를 저장하고 처리한다

2. 컴퓨터는 정보를 비트로 표현한다
   - 비트는 이진 숫자로, 0 또는 1인 수이다
   - 컴퓨터 내부의 모든 것은 십진수가 아닌 비트로 표현된다
3. 비트는 모여서 더 큰 정보를 표현한다
   - 숫자, 문자, 단어, 이름, 소리, 사진, 영화부터 프로그램을 구성하는 명령어까지 모두 비트가 모여 표현된다



### 아날로그와 디지털

> 아날로그(analog)는 유사하다는 뜻의 어원이 있고, 연속적으로 변하는 값이라는 개념을 전달한다
>
> 디지털 시스템은 불연속적인 값을 다루므로 가능한 값의 수가 정해져있다
>
> **컴퓨터의 입장에서는 디지털 데이터가 다루기 쉽다**
>
> 디지털 데이터의 장점
>
> > 저장, 전송, 처리, 압축, 암호화, 병합, 복사, 이동 + 확장성



## 008 아날로그 정보를 디지털로 바꾸기

### 이미지 디지털화 하기

> 사진의 디지털 표현은 계산되어 빛의 강도를 나타내는 수를 배열한 것이다
>
> 검출 소자가 더 많고 전하가 더 정밀하게 측정될수록 디지털화 된 영상이 더 선명하다
>
> RGB검출 소자 세개로 구성되는 센서는 화소(picture element)나 픽셀(pixel)이라고도 한다



### 음향 디지털화 하기

> 바이닐 레코드나 카세트테이프와 달리 디지털 음악은 무료로 **원하는 횟수만큼 복제**가 가능하다
>
> 소리를 시각화 한 기압의 그래프는 아날로그지만, **잘게 쪼개서 디지털 화** 할 수 있다
>
> 변환을 수행하는 장치를 A/D (Analog to Digital) 변환기라 한다
>
> **변환은 결코 완벽하지 않고, 각 방향으로 전환될 때 일부 정보를 잃게 된다**
>
> CD(콤팩트디스크)는 디지털 음향이 소비자에게 전달된 첫 번째 사례였다
>
> LP 레코드의 아날로그 홈 대신 CD는 디스크에 있는 긴 **나선형 트랙에 숫자(비트)를 기록**한다
>
> 소리와 영상은 압축(compression)할 수 있다
>
> 음악은 MP3(MPEG Audio Layer 3)나 AAC(Advanced Audio Coding) 같은 압축기술을,
> 사진은 JPEG(Joint Photographic Experts Group) 압축기술을 사용할 수 있다
> 동영상은 MPEG(Moving Picture Experts Group)로 압축한다



### 영화 디지털화 하기

> 영화는 **이미지를 빠르게 연속해서 보여줌**으로써, 생기는 착시 현상이다
>
> 영화의 디지털 표현은 은향과 영상 요소를 결합하고 동기화 한다



### 텍스트 디지털화하기

> 어떤 종류의 정보는 추가적인 변환 과정 없이 디지털로 어떻게 표현할지 합의하기만 하면 되므로 디지털 변환이 쉽다 (글자가 그렇다)
>
> ASCII (American Standard Code for Information Interchange) 아스키코드가 대표적이다
>
> 전 세계적으론 유니코드(Unicode)라는 단일 표준이 있다
> 유니코드는 모든 언어에 있는 모든 문자에 고유한 숫자 값을 지정한 것이다
> 유니코드에는 14만 개가 넘는 문자가 있고 그 수는 꾸준히 늘고있다
>
> **UTF-8**은 유니코드를 위한 **가변 길이 문자 인코딩 방식** 중 하나
> (Universal Coded Character Set + Transformation Format – 8-bit)
> UTF-8 인코딩은 유니코드 **한 문자를 나타내기 위해 1바이트에서 4바이트까지를 사용**



#### UTF-8

- 장점
  - UTF-8은 모든 [유니코드](https://ko.wikipedia.org/wiki/유니코드) 문자를 표현할 수 있다
  - ASCII 인코딩은 UTF-8의 부분 집합이다. 일반적인 ASCII 문자열은 올바른 UTF-8 문자열이며, 따라서 하위 호환성이 보장된다
  - UTF-8과 UTF-16은 XML (Extensible Markup Language) 문서의 표준 인코딩으로, 다른 인코딩들을 사용하려면 외부에서, 또는 문서 안에서 명시적으로 인코딩을 정해야 한다
  - 다른 인코딩과의 왕복 변환이 간단하다
  - 바이트 단위 문자열 검색 알고리즘들을 그대로 사용할 수 있다
- 단점
  - 한중일 문자들과 표의 문자를 제외한 거의 모든 기존 인코딩들은 한 문자에 1바이트를 사용하므로 문자열 처리가 간편한 반면, UTF-8은 그렇지 않다



## 결론

결론적으로, 디지털 표현은 **숫자 값으로 변환될 수 있는 어떤 것이든 나타낼 수 있고**
**컴퓨터로 처리될 수 있다**
또한 저장, 전송, 처리, 압축, 암호화, 병합, 복사, 이동 + 확장성의 장점을 가진다



## 009 0과 1의 세계

> 이진수 (binary number, 기수가 2인 수)



### 비트 

> bit(binary digit) : 디지털 정보를 표현하는 가장 기본적인 방식, 0과 1만을 사용



## 010 비트 모아 데이터



### 이진수

이진수를 십진수로 표현하는 법

- 각 자리의 수에 2^n 을 곱해 더한다

십진수를 이진수로 표현하는 법

- 십진수를 2로 반복해서 나눠 나머지를 역순으로 기입한다
- 십진수에 포함되는 가장 큰 2^n부터 빼가면서, 0이 될 때까지 뺀다



### 바이트 (byte)

> 모든 최신 컴퓨터의 데이터 처리와 메모리 구성의 기본 단위, **1바이트 == 8비트**
>
> 단일 바이트는 2^8 = 256개의 구별되는 값을 인코딩 할 수 있다
>
> 바이트 **두 개**는 총 16비트이며, 2^16가지 (**65535**)의 값을 나타낼 수 있다
>
> 아스키코드 문자 하나 - 1바이트
>
> 유니코드 문자 하나 - 2바이트

십육진수 (0~9,A,B,C,D,E,F) - 정보의 종류를 나타낸다

어떤 프로그램의 데이터는 다른 프로그램의 명령어가 되기도 한다
프로그램이나 앱을 다운로드할 때 무작정 복사되었던 비트들이,
프로그램을 실행할 때에는 CPU에 의해 처리되면서 명령어로 취급된다



## 011 요약

> 컴퓨터는 왜 십진수가 아닌 이진수를 사용할까?
>
> 물리적인 장치를 만들 때 켜짐과 꺼짐이라는 두 가지 상태만 갖도록 하는 것이
> 열 가지 상태를 갖도록 하는 것보다 훨씬 쉽기 때문이다
>
> 전류(흐름, 흐르지 않음), 전하(존재, 비존재), 자성(N, S), 빛(밝음, 어둠), 반사율(반사율이 높고 낮음)



## 012 프로세서와 계산기의 다른 점

> "기계에 전달된 명령이 숫자형 코드로 변환되고 **기계가 일정한 방식으로 수와 명령을 구분할 수 있다면**, 기억 기관은 수와 명령 둘 다 저장되는 데 사용될 수 있다"
>
> 프로세서는 컴퓨터의 가장 중요한 구성 요소이다



#### 프로세서의 작동

- 산술 연산 (계산기의 산술 기능)
- 메모리에서 연산을 수행 할 데이터를 가져오거나, 연산 결과를 메모리에 저장 (계산기의 메모리 기능)
- 컴퓨터의 나머지 부분을 제어
  - 버스로 전송되는 신호를 통해 마우스, 키보드, 디스플레이, 기타 전기적으로 연결 된 모든 장치에 대한 입력과 출력을 조직화하고 조정한다

- **중요한 점은 프로세서가 비록 단순하긴 해도 결정을 내릴 수 있다는 것이다**
  - 비교 연산 등을 통해 사람의 개입 없이 (독립적으로) 작동하여, 스스로 전체 시스템을 운영할 수 있다



## 013 모형 컴퓨터로 더하기 프로그램 만들기

> 컴퓨터의 작동법을 이해하기 위해, 상상으로 만든 컴퓨터를 '모형 컴퓨터'라고 한다
>
> 모형 컴퓨터에는 명령어와 데이터를 저장하기 위한 메모리가 있고,
> 한개의 수를 담을 만한 용량의 부가적인 저장 영역인 누산기가 있다고 하자
>
> 모형 컴퓨터에는 기본 연산을 수행하기 위한 약 10개의 명령어 레퍼토리가 있다

모형 컴퓨터의 대표적인 명령어

- GET - 키보드에서 수를 입력받은 후 누산기에 넣는다 (누산기의 기존 내용을 덮어쓴다)
- PRINT - 누산기의 내용을 출력한다 (누산기의 내용은 변하지 않는다)
- STORE M - 누산기 내용의 복사본을 메모리 위치 M에 저장한다 (누산기의 내용은 변하지 않는다)
- LOAD M - 메모리 위치 M의 내용을 누산기에 적재한다 (M의 내용은 변하지 않는다)
- ADD M - 메모리 위치 M의 내용을 누산기의 내용에 더한다 (M의 내용은 변하지 않는다)
- STOP - 실행을 중지한다



각 메모리 위치에 한 개의 수 또는 한 개의 명령어가 담겨 있으므로, 프로그램은 메모리에 저장된 일련의 명령어와 데이터 항목으로 구성된다

작동을 시작하면 프로세서는 첫 번째 메모리 위치에서 시작해서 다음과 같이 단순한 사이클을 반복한다

- 인출 Fetch: 메모리에서 다음 명령어를 가져온다
- 해석 Decode : 명령어가 무슨 일을 하는지 알아낸다
- 실행 Excute : 명령어를 실행한다.
- 인출 단계로 되돌아간다



#### 프로세서의 명령 처리

> 프로세서는 프로그램의 처음부터 시작해서 **명령어를 한 번에 한 개씩** 가져온다
> 각 명령어를 **차례차례 실행하고 다음 명령어로 넘어간다** - 레지스터



#### 프로세서의 데이터 저장 방식

> 데이터는 명령어로 해석되지 않을 메모리 공간 어딘가에 저장해 두어야 하는데,
> **데이터 값을 모든 명령어 다음에 오도록 프로그램의 끝에 두면**,
> 프로세서는 절대로 데이터 값을 명령어로 해석하려고 시도하지 않는다 (데이터 값 도달 전에 Stop 한다)



#### 데이터의 위치 파악

> 프로그램의 명령어가 메모리 위치를 필요로 할 때, 그 **메모리 위치를 나타내는 방법**은,
> **데이터 위치에 이름을 부여**하는 것이다



#### 분기 명령어

> 프로세서의 명령어 레퍼토리에 **일련의 명령어를 재사용하게 하는 새로운 종류의 명령어**이다
> 종종 '분기' 또는 '점프'라고 불리는 GOTO 명령어는 바로 다음 명령어가 아니라 GOTO가 지정하는 위치로 이동하여 명령어를 실행하도록 프로세서에 지시한다
>
> GOTO 명령어를 사용하면 **프로세서가 프로그램의 앞부분으로 돌아가서 명령어 처리를 반복**하도록 할 수 있다



##### 조건부 분기 (conditional branch)

> **분기 명령어의 루프를 멈추는 명령어** 조건부 점프 (conditional jump)라고도 한다
>
> 값이 0인지 검사하여, 특정한 명령어로 건너뛰는 명령어이다
>
> False = 0



유사 명령어 - sum:0 (선언 및 초기화 역할)



#### 프로그램 테스트

> **체계적으로 테스트** 하는 것이 중요하다 - 예외 상황이나 특이한 상황을 가정하여 테스트



#### 메모리 내부 표현

> 메모리 위치를 한개 사용하는 GET 같은 명령어도 있고,
> 다른 메모리 위치도 참조하기에 메모리 위치를 두개 사용하는 IFZERO나 ADD같은 명령어도 있다



## 014 프로세서는 무조건 빠른게 좋을까?

> 프로세서는 인출, 해석, 실행 사이클을 계속 반복 수행한다
>
> 1. 메모리에서 다음에 처리할 명령어를 인출한다
> 2. 가져온 명령어를 해석한다
> 3. 명령어를 실행한다
> 4. 다시 1의 인출단계로 돌아간다

컴퓨터 아키텍처는 **프로세서 설계**와 더불어 **프로세서와 컴퓨터 나머지 부분 간의 연결 방식 설계**를 다루는 분야다컴퓨터 아키텍처 분야의 주요 관심사 중 하나는 명령어 집합(instruction set)이고, 이 명령어 레파토리의 종류와 속도, 편의성 등등은 트레이드 오프 관계이다
**컴퓨터 아키텍처는 기능성, 속도, 복잡도, 전력 소모 정도, 프로그램 가능성 등 상충하는 요구 간 복잡한 트레이드 오프(trade off)를 수반한다**

현대 컴퓨터 아키텍처는 **캐시(cache)라는 고속 메모리**를 몇 개 사용한다
캐시는 프로세서와 메모리 사이에 있고, 최근 사용된 명령어와 데이터를 담고 있다

프로세서가 더 빨리 작동하도록 만들기 위해 여러가지 아키텍처 기법을 동원한다
그 중 하나가 인출과 실행 단계가 겹치도록 프로세서를 설계해서 명령어 여러 개가 다양한 단계에 걸쳐 진행되도록 만드는 것이고, 이를 **파이프라이닝**이라 한다. 또 다른 기법은 명령어들이 서로 간섭하거나 의존하지 않는다면 다수의 명령어를 **병렬**적으로 **실행**하는 방법이다

그 밖에도 프로세서 여러 개가 동시에 작업하도록 하는 기법이 있고, 이는 노트북과 휴대폰에서 표준으로 사용한다

사용 분야에 따라 프로세서를 설계할 때 다양한 종류의 트레이드오프가 이뤄지고, 프로세서의 속도 뿐만 아니라 다양한 기능적 특성을 고려한다. 그러므로 **어떤 프로세서가 다른 것보다 '빠르다'는 주장은 조심스럽게 받아들여야 한다**. 요구사항에 따라 차이가 있을 수 있다

누산기 = 레지스터

> 컴퓨터의 중앙 처리 장치(CPU)에서 중간 산술 논리 장치 결과가 저장되는 레지스터
>
> [레지스터](https://ko.wikipedia.org/wiki/레지스터)가 없으면 다음 연산을 위해 다시 읽을 수 있도록 각각의 계산(더하기, 곱하기, [시프트](https://ko.wikipedia.org/wiki/비트_연산) 등)의 결과를 주 기억장치에 기록할 필요가 있다. 주 기억장치에 대한 접근은 누산기와 같은 레지스터에 접근하는 것 보다 더 느린데, 이는 대형 주 메모리에 사용되는 기술이 레지스터에 사용되는 것 보다 더 느리기(그러나 값은 더 저렴함) 때문이다.
>
> 현대의 컴퓨터 시스템들은 종종 누산기의 역할을 하는 여러 개의 범용 레지스터를 갖추고 있으므로 이 용어는 더 이상 과거처럼 일상적으로 쓰이지 않는다.



## 015 캐시가 뭔가요?

my) **재사용 편의성**

> "그러므로 우리는 메모리를 계층 구조로 만들 가능성이 있음을 결국 인식하게 된다. 여기서 **각 단계의 메모리는 앞 단계**보다 **용량은 더 크고** 접근 **속도는 느리다**"

> 프로세서에서 **캐시는 용량이 작고 속도가 빠른 메모리**로, 용량이 더 크지만 훨씬 느린 
> **주 기억 장치에 매번 접근하는 것을 피하고자 최근에 사용된 정보를 저장**하는 데 사용된다
>
> 일반적인 프로세서에는 캐시가 2~3개 있는데, 흔히 L1, L2, L3레벨이라고 부르고 뒤로 갈수록 용량은 크지만 속도는 더 느리다 (L1이 가장 빠르고 L3가 가장 느림)

#### 캐싱

>**캐시 영역으로 데이터를 가져와서 접근하는 방식**
>
>우리가 뭔가를 사용하고 있고 그것을 **곧 다시 쓸 가능성(시간적 지역성)**이 있거나 **근처에 있는 뭔가를 사용할 가능성(공간적 지역성)**이 있을 때 언제든지 활용할 수 있는 훨씬 더 일반적인 개념이다
>
>캐싱이 효과적인 이유는 최근에 사용된 정보가 곧 다시 사용될 가능성이 크기 때문이다
>캐시는 **연속된 메모리 위치를 포함한 데이터 블록**을 불러오는 데, 이는 인접한 정보가 사용될 가능성이 높기 때문이다



#### 캐시의 관리

> 웹 브라우저에서 '캐시를 삭제한다'라는 문장을 본 적 있을 것이다
> 브라우저는 어떤 웹페이지에 포함된 이미지나 **비교적 용량이 큰 다른 데이터의 로컬 사본**을 유지하고 있다
> 단, 캐시의 용량은 한정돼 있으므로 브라우저는 오래된 항목부터 자동으로 제거한다 (수동삭제도 가능하다)
>
> 워드나 엑셀같은 프로그램에 있는 최근에 사용된 파일 목록도 일종의 캐싱이다





## 016 슈퍼컴퓨터부터 사물인터넷까지

수퍼컴퓨터는 과학기술 연산을 비록한 다양한 분야에 사용되는 고속 컴퓨터로, 보통 많은 수의 프로세서와 대량의 메모리를 사용한다. 사용되는 **프로세서 자체도 특정 종류의 데이터를 훨씬 빨리 처리하는 명령어로 구성**되어 있다.

**GPU** [ Graphics Processing Unit]는 범용 CPU보다 그래픽 관련 계산을 훨씬 빠르게 수행하는 그래픽 전용 프로세서이고, 일반 프로세서가 특정한 종류의 작업을 빠르게 처리하는 데 도움을 준다
GPU는 간단한 산술 연산을 병렬로 대량처리 할 수 있다 (특히 머신러닝에 유용하다)

**분산 컴퓨팅**(distributed computing)은 네트워크로 연결되어 서로 독립적으로 작동하는 여러대의 컴퓨터를 일컫는 말이다
분산 컴퓨팅 시스템은 메모리를 공유하지 않고 물리적으로 넓게 흩어져 있다
검색 엔진, 온라인 쇼핑, SNS, 일반적인 클라우드 컴퓨팅 같은 대규모 웹 서비스가 분산 컴퓨팅 시스템으로 이루어져 있고, 수천 대의 컴퓨터가 많은 사용자에게 결과를 빨리 제공하고자 상호 작용한다

**튜링 머신**(Turing machine) 수학자 앨런 튜링이 에 제시한 개념으로, 계산하는 기계의 일반적인 개념을 설명하기 위한 가상의 기계이며 오토마타의 일종이다
현대의 폰 노이만 구조로 된 컴퓨터는 모두 보편 튜링 머신 이론에 바탕을 두고 있다. 따라서 보편 튜링 머신은 현대의 모든 컴퓨터를 흉내낼 수 있다.

**튜링 테스트와 역 튜링 테스트**
둘 다 블라인드 테스트이다.
튜링 테스트는 **문자**로 소통할 때, 소통하는 대상이 인간인지 컴퓨터인지 **구분할 수 없다면 컴퓨터가 인간 수준의 지식을 가지고 있다는 결론**을 내리는 테스트이고
역 튜링 테스트는 캡챠(CAPTCHA)와 같이 **시각이나 청각 데이터**를 통해 **컴퓨터와 인간을 구분**하는 테스트이다



# 소프트웨어

컴퓨터는 필수 시스템(critical system) 네가지(안전 필수, 임무 필수, 사업 필수, 보안 필수) 에서 핵심을 차지한다



## 018 알고리즘과 초콜릿 케이크 레시피

> 소프트웨어를 설명할 때 음식을 만드는 레시피에 자주 비유하곤 한다 - 납세 신고서가 더 적절하긴 하다
> 레시피(프로그램)는 요리에 필요한 재료(연산에 필요한 데이터),
> 요리사가 수행해야 하는 작업 순서(데이터에 대해 수행할 작업),
> 그리고 예상되는 결과를 열거한다
>
> 알고리즘은 결과를 정확하게 계산하도록 보장된 일련의 단계이다
> 알고리즘에 모호함이 있으면 안되고, 모든 가능한 상황을 다뤄야하며, 결국엔 결과를 반환하고 멈춰야한다



## 019 반에서 가장 키 큰 사람 찾기: 선형 알고리즘

> 알고리즘의 중요한 특성 하나는 얼마나 효율적으로 작동하는가이다
>
> 계산 시간이 데이터의 양에 정비례하거나 선형적으로 비례할 때, 선형 알고리즘이라 한다



## 020 10억개 전화번호에서 이름 찾기 : 이진 탐색

> 배열이 정렬되어 있다면, 현재 배열의 절반의 중간을 탐색하여 나온 두 그룹 중 한쪽 그룹만을 선택하여 검색해 나가는 걸 반복하면 된다
>
> 이진 검색은 분할 정복이라는 일반적인 전략의 한 가지 예다
>
> 검색의 횟수는 log_2에 비례하기 때문에 적은 횟수로 많은 데이터를 다룰 수 있다



## 021 검색을 쉽게 만드는 정렬 : 선택 정렬 VS 퀵 정렬

> 이진 검색을 위해서는 정렬이 필요하다
> 정렬은 항목을 순서대로 배열해서 검색이 빨리 실행될 수 있도록 해준다

### 선택 정렬

배열을 돌면서 최솟값을 선택한다 (한 번 돌때 1개씩 선택한다)
O(n^2)이다

### 퀵 정렬

반씩 나눠가면서 정렬한다

O(nlog_2n)의 시간복잡도를 갖는다



## 022 10개 도시를 최단거리로 여행하는 법

> 알고리즘 복잡도
>
> > *logN*
> >
> > - 효율이 높다
> > - 이진 검색 등이 있다
> >
> > *N*
> >
> > - 가장 일반적인 경우
> > - 일의 양이 데이터 양에 정비례한다
> >
> > *NlogN*
> >
> > - N보다는 효율이 낮지만 효과적으로 사용할 수 있다
> > - 퀵 정렬 알고리즘 등이 있다
> >
> > *N^2*
> >
> > - 일의 양이 너무 많다
> > - 활용 불가능한 수준이 많다
> >
> > **지수 알고리즘**
> > 2^N
> >
> > - 지수 알고리즘에서는 일의 양이 유난히 빠르게 늘어난다
> > - 한 개의 항목을 추가하면 할 일의 양이 "두 배"가 된다

### 지수 알고리즘

> 지수 알고리즘은 사실상 모든 가능한 경우를 하나씩 시도해 봐야만 하는 상황에서 발생한다
>
> 지수 알고리즘이 필요한 문제 - 암호 기법에 사용되는 알고리즘은 은밀한 지름길을 모르면, 지수 알고리즘 복잡도의 설계를 해서 보안을 강화한다



### P문제와 NP문제

> 사실 많은 학자들은 P≠NP일 것이라고 믿는다. 이유는 간단한데, 수많은 학자들이 여러 NP 문제들에 대해서 '다항식 시간 내에 풀 수 있는 알고리즘'을 찾으려고 노력해 왔지만 전혀 성과가 없었기 때문이다
>
> 또한, 임의의 명제를 증명하는 문제는 NP이고, 검증하는 문제는 P인데, 증명은 검증보다 본질적으로 어려운 문제일 것이므로 NP와 P가 같을 수 없다는 믿음이 있다. P=NP가 의미하는 바란, 만약 어떤 문제가 주어졌을 때 그 문제의 답안을 쉽게 검산할 수 있다면 그 문제 자체도 쉽게 풀 수 있다는 대단히 강력한 주장인데, 이는 우리가 지금까지 열심히 수학을 공부하면서 몸에 체득해온 직관과 배치되는 일이다. 일부 방정식의 경우 해를 직접 구하는 것은 어렵지만, 남이 미리 풀어서 구한 답을 방정식에 대입해서 그게 맞는지 확인하는 일은 훨씬 쉬운 경우가 많다.

- NP문제 - 비결정적 다항 [ Nondeterministic Polynomial ]문제
  - **해결책을 빨리 찾을 수는 없지만**, 어떤 해결책을 알고 있다면 그것이 맞는지는 **빨리 입증**할 수 있다



#### 여행하는 외판원 문제 - NP문제 예시

> 외판원은 자신이 사는 도시에서 출발해 어떤 순서로든 다른 도시를 모두 방문하고 나서, 다시 출발점으로 돌아와야한다
> 여기서 목표는 각 도시를 정확히 한 번씩(반복없이) 방문하고, 전체 여행한 거리를 최소로 만드는 것이다
> (통학 버스나 쓰레기차가 다니는 경로를 효율적으로 만드는 일과 아이디어가 같다)

##### 휴리스틱 해법 - 직관적으로 와 닿는 해법

> 한 도시에서 시작해서 매번 **아직 방문하지 않은 도시 중 가장 가까운 도시로 이동하는 방식**
>
> 도시가 바뀌면 여행 경로가 바뀔 수 있다

##### 모든 경우의 수 탐색

> N이 작을때는 사용할 만 하다



## 024 알고리즘은 이상, 프로그래밍은 현실

### 알고리즘

- 추상적이고 이상적인 절차를 기술한 것으로, 구현에 필요한 세부 사항과 현실적인 고려 사항을 무시한다
- 정확하고 명료한 레시피로써, 기본 연산을 사용하여 각 단계를 상세히 설명하고 모든 가능한 상황을 다룬다

### 프로그램

- 추상적인 것과는 거리가 멀다
- 실제 컴퓨터가 과제를 완료하기 위해 수행해야 하는 모든 단계를 구체적으로 서술한다



> 알고리즘과 프로그램간의 차이는 청사진과 건물 간의 차이와 비슷하다
> 알고리즘은 이상적인 것이고, 프로그램은 실재하는 것이다
>
> **프로그램** => **알고리즘이 컴퓨터가 직접 처리할 수 있는 형태로 표현된 것** 이라고 표현 할 수 도 있다

#### 운영체제

> **컴퓨터가 자신의 동작을 직접 제어할 수 있게 해준다**



## 025 다른 프로그램을 처리하기 위한 프로그램

> 1950년대 초, 프로그래밍할 때 수반되는 단순한 반복 작업을 처리하기 위한 프로그램이 몇 가지 만들어졌는데, 이 덕분에 프로그래머들은 명령어에 의미 있는 단어를 붙이고 특정 메모리 위치를 나타내는 이름을 사용할 수 있었다.
> 다른 프로그램을 처리하기 위한 프로그램이라는 강력한 아이디어는 소프트웨어에서 가장 중요한 발전을 이루는 데 핵심적인 기여를 했다
>
> 이처럼 특정한 처리를 수행하는 프로그램을 **어셈블러(assembler)**라고 하고,
> 이 프로그램 작성에 사용되는 언어는 어셈블리 언어,
> 이 수준의 프로그래밍은 어셈블리 언어 프로그래밍이라고 한다
>
> 어셈블러는 프로그램을 수정하는 일을 훨씬 쉽게 해준다.
> 프로그래머가 명령어를 추가하거나 삭제할 때 변경 기록을 직접 관리하는 대신, 어셈블러가 각 명령어와 데이터 값이 메모리상 어느 위치에 있을지 파악해 주기 때문이다
>
> 특정 프로세서 아키텍처에서 사용되는 어셈블리 언어는 **그 아키텍처에 특화된 언어**다
> **어셈블리 언어는 대개 프로세서의 명령어와 일대일로 연결**되고, 명령어가 **이진수로 인코딩**되는 특정한 방식과 메모리에 정보가 배치되는 방식 등을 알고 있다
> 즉, 어떤 작업을 수행하기 위해 특정 종류의 프로세서의 어셈블리 언어로 작성된 프로그램은 다른 프로세서에 맞춰 작성된 어셈블리 언어 프로그램과는 다르다는 뜻이다.



## 026 고수준 언어에서 프로그램 실행까지

> 특정 프로세서 아키텍처에 독립적인 **고수준 프로그래밍 언어(high-level programming language)**의 개발로, **사람이 표현하는 방식에 가까운 용어로 계산 과정을 작성** 할 수 있게 되었다
>
> 고수준 언어로 작성된 코드는 번역기 프로그램을 통해 대상 프로세서의 어셈블리 언어로 된 명령어로 변환된 다음, 어셈블러에 의해 비트로 변환되어 메모리에 로드되고 실행된다 (여기서 번역기 프로그램은 보통 컴파일러(compiler)라고 불린다)
>
> 고수준 언어는 어셈블리 언어에 비해 큰 이점을 갖는다
>
> 1. 사람들이 생각하는 방식에 더 가까워 배우고 사용하기 쉽다
> 2. 특정 아키텍처(운영체제 플랫폼)에 종속되지 않는다 (고수준 언어로 작성된 프로그램은 여러 아키텍처상에서 실행될 수 있다) - 다른 컴파일러로 컴파일 하기만 하면 된다
> 3. 컴파일 단계에서 몇 가지 명백한 에러를 미리 점검할 수 있다 (철자 오류, 구문 오류, 정의되지 않은 변수에 대한 연산 등 )
>
> 각 **어셈블러**는 각자의 **어셈블리 언어 명령어를 실제 명령어의 비트 패턴으로 변환**하는 일 뿐만 아니라, **변수를 저장할 메모리 위치를 확보**하는 일을 담당한다
> **비트 패턴**은 각각의 컴퓨터에 대해 거의 **완전히 다르게 변환**된다
>
> `고수준 언어 =(컴파일러)=> 해당 프로세서의 어셈블리 언어 =(어셈블러)=> 비트`



## 언어별 덧셈 프로그램 작성

> 0이 입력되기 전까지의 숫자들의 합을 반환한다



### 포트란 (FORTRAN)

> 1958년
>
> 초기 고수준 언어
> 과학과 공학 분야에서 사용

### 코볼 (COBOL)

> 1950년 후반
>
> 사무 데이터 처리 목적으로 사용

### 베이직

> 1964년
>
> 개인용 컴퓨터에서 사용 할 수 있는 첫 번째 고수준 언어
> 마이크로소프트 비주얼 베이직으로 변종



## 027 작문과 비슷한 프로그래밍

### C

> 1973년
>
> 시스템 프로그래밍 용도로 제작

### C++

> 1980년대
>
> 규모가 매우 큰 프로그램을 위해 개발됨
> C에서 진화한 언어

- 오늘날 컴퓨터에서 사용되는 **주요 프로그램 대부분은 C나 C++**로 작성됐다

  > C와 C++로 만들어진 프로그램들

  - 맥 소프트웨어 => C, C++, 오브젝티브-C
  - 편집, 서식, 정리, 출력 프로그램 => C, C++
  - 파이어폭스, 크롬, 엣지 => C++
  - 유닉스, 리눅스 운영체제 => C



### Java

> 1990년대 초
>
> 컴퓨터의 효율보단, **프로그래밍을 편하게 하는 것에 초점**을 둔 언어
>
> 속도는 그다지 중요하지 않지만, 유연성이 중요한 가전 제품과 전자기기에 사용할 임베디드 시스템으로 개발
> 웹 서버에 널리 사용된다

### JavaScript

> 1995년
>
> 웹페이지의 동적인 효과를 구현하기 위해 브라우저 내부에서 사용할 목적으로 설계
> 컴파일러가 모든 브라우저에 내장되어 있다

### Python

> 1991년
>
> 가독성에 초점을 두고 설계됨
> 거의 모든 프로그래밍 과제에 필요한 라이브러리를 풍부하게 제공



#### 프로그래밍의 발전 방향

- 컴퓨터 자원이 풍부해 지므로, **프로그래밍은 쉬워지게 발전** 할 것
- 프로그래머가 더 안전하게 사용할 수 있는 언어를 만드는 방향으로 발전 할 것

> 벤자민 워프 "언어는 우리가 생각하는 방식을 형성하고, 생각할 수 잇는 범위를 결정한다"



## 028 구글 같은 서비스는 어떻게 개발할까?

현실에서 대규모로 이뤄지는 프로그래밍의 전략

1. 무엇을 해야할지 파악
2. 넓은 명세부터 시작해 점차 작은 부분으로 나눈다
3. 각 부분을 작업하면서 전체적으로 일관되어 있는지 확인

> 프로그래밍에서 작업 하나의 크기는 보통 한 사람이 프로그래밍 언어로 정확한 처리 단계를 작성할 수 있는 정도 (몇 천 줄 정도)

2015년 구글의 전체 코드 규모는 **약 20억 행** 이었다
이 정도 규모의 소프트웨어를 개발하려면 프로그래머, 테스트 담당자, 문서 작성자로 이루어진 팀이 여럿 필요하고,
프로젝트의 진행을 위해 일정과 마감 시한을 정하는 등 여러 계층에 걸친 관리와 회의가 이루어져야 한다



### 라이브러리, 인터페이스, 개발 키트

> 프로그래머는 미리 만들어진 부품을 사용한다
> **프로그래밍 작업의 대부분은 이미 있는 구성 요소를 이해하고, 자신만의 방식으로 이어 붙이는 것이다**

#### 함수

> **함수**를 이용하면 따로 만들어진 구성 요소를 필요에 따라 적절하게 조합하여 프로그램을 만들 수 있다

#### 라이브러리

> 연관된 함수들의 모음을 보통 라이브러리라고 한다
>
> 함수 라이브러리가 제공하는 서비스는 **애플리케이션 프로그래밍 인터페이스 (API [ Application Programming Interface ])**로  프로그래머에게 제공된다

#### 인터페이스

> API는 포함하는 함수와 더불어 함수의 용도가 무엇인지, 함수를 어떻게 사용해야 하는지, 어떤 입력 데이터를 요구하는지, 어떤 값을 만들어 내는지 나열한다
> 또한, API는 시스템 내부에서 주고받는 데이터의 구조를 의미하는 자료 구조와 기타 세부 사항도 기술 할 수 있다
>
> 이 모든 것이 모여 프로그래머가 서비스를 요청하기 위해 무엇을 해야 하고, 결과적으로 무엇이 계산될지 정의한다

#### 소프트웨어 개발키트

> API는 구문과 관련된 기본 명세뿐만 아니라 시스템을 효과적으로 사용하도록 돕는 지원 문서도 포함한다
>
> 요즘 대규모 시스템은 프로그래머들이 복잡한 소프트웨어 라이브러리를 잘 다룰 수 있도록 **소프트웨어 개발키트 (SDK [ Software Development Kit ])**를 포함한다, **프로그래밍 개발 환경**이라고 생각하면 이해하기 쉽다



### 버그

> 컴퓨터가 시키지도 않은 엉뚱한 일을 처리하거나 잘못된 답을 내놓는 경우에, 이를 버그라 한다
>
> 버그를 일으키는 수많은 원인으로는, 발생할 수 있는 경우를 깜박하고 처리하지 못 했거나 **(예외처리)**, 어떤 조건을 평가하기 위한 논리 테스트나 산술 테스트를 잘못 작성했거나**(논리오류)**, 잘못된 공식을 사용했거나, 프로그램이나 프로그램의 특정 부분에 할당된 영역 밖에 있는 메모리에 접근했거나**(포인터오류)**, 특정 종류의 데이터에 잘못된 연산을 적용했거나**(타입오류)**, 사용자의 입력이 적합한지 검사하지 못한 경우 등이 있다



### 테스트

> 테스트는 실제로 프로그래밍에서 큰 부분을 차지한다
> 소프트웨어를 개발하는 기업에는 (버그를 줄이기 위해) 흔히 **구현 코드보다 테스트 코드가 더 많고**, **프로그래머보다 테스터가 더 많다**



### 보안

> 버그는 시스템을 공격에 취약하게 만들기도 하는데, 버그 때문에 종종 공격자가 메모리에 악성코드를 심어 놓기 쉬워지기도 한다
>
> 업데이트가 잦다는 것은 그만큼 취약점이 널리 퍼져 있다는 것을 뜻한다
> 견고한 프로그램을 작성하는 일은 어렵다



### 유지보수

> 소프트웨어 개발에 복잡함을 더하는 또 다른 요인은 급변하는 환경이다
> 환경은 항상 변하고 프로그램은 거기에 발 빠르게 대응해야 한다
>
> 끊임없는 변화에 뒤쳐지지 않고 따라가는 것은 소프트웨어 유지보수에서 매우 중요하며, 반드시 수행해야 하는 일이다



## 029 구글과 오라클의 저작권 소송

**IP** [ Intellectual Property ] - 지적 재산권

> 발명이나 저작(책, 음악, 그림, 사진 등) 같은 개인의 창작 활동에서 생겨난 다양한 종류의 무형자산



소프트웨어는 IP이다



## 030 기술 표준의 중요성

> 표준은 어떤 기술적 산물이 어떻게 만들어지고 어떻게 작동하도록 되어있는지 명확하고 상세하게 기술한 것
>
> '표준'이라는 용어는 무언가가 어떻게 만들어지고 작동하는지 정의하는 정규화된 표현을 뜻한다고 보는 것이 적합하며, 보통은 정부 기관이나 컨소시엄 같은 준중립적인 단체에 의해 개발되고 유지된다
> 경쟁 관계에 있는 표준도 존재한다
>
> 하드웨어 표준의 예시 - 콘센트, TV, 각종 케이블 등
>
> 소프트웨어 표준의 예시 - 아스키코드, 유니코드, 프로그래밍 언어, 암호화와 압축 알고리즘, 프로토콜 등



## 031 자유로운 소프트웨어, 오픈소스

> 소스 코드 -프로그래머가 작성하는 언어
>
> 오브젝트 코드 - 소스 코드를 컴파일한 결과



## 060 ZIP 파일로 압축할 때

> 압축의 목표
>
> > 같은 정보를 더 적은 비트로 인코딩 하는 것
>
> 압축의 기본 아이디어
>
> > 군더더기 정보(수신단에서 재현하거나 유추할 수 있는 정보)는 저장하거나 보내지 않는 것

### 텍스트 압축

모든 글자에 8비트를 할당하지 않고, 더 자주 사용하는 글자의 비트수를 줄여서 사용

ex) 오만과 편견 원문 문자 수  (횟수)

1 - 공백(110000), 2 - e(68600), 3 - t(45900), 4 - a(31200)

X(0), Z(3), j(551), q(627), x(839)



### 이미지 압축 







# 통신



## 079 곳곳에 도사리는 위험

> 웹은 상당수의 복잡한 보안 문제를 제기한다
>
> 보안 위협은 대체로 세 가지 범주로 나뉜다
>
> - 클라이언트 공격
> - 서버 공격
> - 전송 중인 정보 공격 (무선 통신 스누핑, NSA가 광케이블상의 모든 트래픽 탈취)



### 클라이언트 공격
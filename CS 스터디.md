> 1일 1로그 100일 완성 [브라이언 W.커니핸 지음]

| CS 스터디 [ Computer Science ] |
| ------------------------------ |

> 서론 중
>
> 디지털 세상의 4가지 핵심 아이디어
>
> 1. 정보의 보편적 디지털 표현 - 저수준 디지털 데이터
> 2. 보편화된 디지털 처리 장치 - 작동방식이 동등하여 기계간 융합 및 동기화 진행 중
> 3. 보편화된 디지털 네트워크 - 세계적 인프라 구축
> 4. 어마어마한 양의 디지털 데이터 수집 및 분석



CS 공부는 왜 해야할까

> 알고리즘 시험과 다르게 무조건 보는 기술면접에  CS 지식이 필요함

CS 공부 방법

> 관련 서적, 구글링, 깃허브



# 하드웨어

> 1부에서는 컴퓨터 하드웨어에 관해 설명하며, 컴퓨터 시스템의 논리적 아키텍처에 초점을 준다.
>
> "완성된 장치가 범용 컴퓨팅 기계가 되려면 산술 연산, 기억-저장, 제어, 운영자와의 연결을 담당하는 특정 주요 기관을 포함해야 한다" - 아서 벅스, 허먼 골드스타인, 존 폰 노이만.. 1946



## 001 컴퓨터의 논리와 구조

컴퓨터의  두 가지 측면 - 논리적(기능적) 구성, 물리적 구조

컴퓨터의 종류는 달라도, 내부 작동 원리는 근본적으로 같다 - 추상적인 기능은 바뀌지 않음



## 002 프로세서 속도와 심장 박동수

- 폰 노이만 아키텍처
  - **프로세서**, 명령어와 데이터를 담는 **메모리와 저장 장치**, **입력**과 **출력**장치가 있는 기본구조
- 프로세서 - CPU [ Central Processing Unit ]
- 주 기억 장치 - RAM [ Random Access Memory ]
- 보조 기억 장치 - 디스크, 드라이브



### 프로세서 [ processor ]

> 컴퓨터의 두뇌에 해당한다.
>
> 프로세서는 산술 연산을 하고, 데이터를 여기저기로 옮기며, 다른 구성 요소의 작업을 제어한다.
>
> 컴퓨터 부품 중에서 코어 [ core ]가 프로세서에 해당한다.
>
> 헤르즈 Hz는 1초에 프로세서가 수행하는 연산이라고 보면 된다.



### 주 기억 장치 [ primary memory ]

>컴퓨터가 실행되는 동안 정보를 저장할 장소를 제공한다.
>
>프로세서가 현재 작업 중인 데이터뿐만 아니라 프로세서가 그 데이터로 무엇을 해야 하는지 알려주는 명령어도 저장한다. 메모리에 다른 명령어를 로드(적재)하여 프로세서가 다른 계산을 수행하게 할 수 있다. 이를 **프로그램 내장식** 이라하며, 다양한 작업을 가능하게 해준다.
>
>주 기억 장치를 RAM이라고 부르는 이유는, **프로세서가 정보에 접근할 때 메모리에 저장된 위치와 무관하게 같은 속도로 접근할 수 있기 때문**이다. 대부분의 메모리는 **휘발성 [ volatile ]**이다. 전원이 꺼지면 메모리의 내용이 사라지고 현재 활성화 된 모든 정보가 사라진다는 뜻이다.
>
>메모리 용량에는 어떤 의미가 있을까? 대게 **메모리 용량이 클수록 컴퓨팅 속도가 더 빠르다**고 볼 수 있다. 메모리가 작으면 동시에 여러 프로그램을 실행하기에 용량이 충분하지 않고, 비활성화 된 프로그램의 일부를 옮겨 새로운 작업을 위한 공간을 만드는 데 시간이 걸리기 때문이다.



## 003 HDD와 SSD의 차이



### 보조 기억 장치

> 전원이 꺼져 있을 때도 정보를 유지하는 장치



#### HDD

> 자기 디스크 (하드 디스크, 하드 드라이브)
>
> 회전하는 금속 표면에 있는 자성 물질을 읽어 데이터를 읽는다
>
> 주 기억 장치보다 저렴하지만 속도가 느리다



#### SSD [ Solid State Drive ]

> 회전하는 기계 장치 대신 **플래시 메모리 [ flash memory ]**를 사용한다
>
> 전원이 꺼져 있어도 개별 소자의 전하를 유지하는 회로에 정보가 전하 형태로 저장된다
>
> 저장된 전하를 읽어 값이 무엇인지 확인 할 수 있고, 삭제하고 새 값으로 덮어 쓸 수도 있다
>
> 기존의 디스크 저장 장치보다 더 빠르고 가볍고 안정적이며, 내구성과 전기소모효율이 좋다



#### 추상화

> 컴퓨터의 논리적 구조와 물리적 구현 간에는 차이가 많지만, 소프트웨어는 추상화를 통하여 정보가 물리적으로 저장되는 방법과 무관하게 계층구조로 보이게 만든다
>
> 물리적 구현을 이해하지 못하더라도, 논리적 구조를 사용할 수 있다



#### 다른 장치들

> 실제로 컴퓨터 내부에 여러가지 버스가 있고, 각각 그 기능에 적합한 속성이 있다
>
> 프로세서와 메모리 사이를 연결하는 버스는 짧고 빠르지만 비싼 반면,
> 헤드폰 잭에 연결되는 버스는 길고 느리지만 저렴하다

- 입력
  - 마우스, 키보드, 터치스크린, 마이크, 카메라, 스캐너 등등
- 출력
  - 디스플레이, 프린터, 스피커 등등



## 004 가로세로 1cm 프로세서 칩

> 컴퓨터 부품이 올라가 있는 회로 기판에서는 발전 양상이 명확히 드러난다
> 20년 전 많은 회로, 배선, 연결 핀이 조밀하게 배치된 것과 비교하면, **요즘에는 부품의 수가 더 적다**
>
> 컴퓨터의 전자 회로는 몇 가지 기본 소자가 매우 많이 모여 만들어지는데,
> 가장 중요한 기본 소자로는 논리 게이트 (logic gate)를 들 수 있다
> 논리 게이트는 한 개나 두 개의 입력 값을 바탕으로 단일 출력 값을 계산해 낸다
> 이러한 게이트가 필요한 만큼 적절한 방식으로 연결되면 어떤 종류의 계산도 수행할 수 있다
>
> 논리 게이트는 집적회로 (IC [ Integrated Circuits ])상에서 만들어진다
> 집적회로는 흔히 칩(chip) 또는 마이크로칩(microchip)이라 한다
> 집적회로는 개별 부품과 재래식 전선이 없으며,
> 이 회로를 만들기 위해 복잡한 광학적, 화학적 공정을 거친다
> 따라서 집적회로는 개별 부품으로 만들어진 회로보다 훨씬 작고 견고하다
>
> 회로 소자에서 가장 핵심적인 부분은 트랜지스터 (transistor)이다
> 컴퓨터에서 트랜지스터는 기본적으로 스위치 역할을 한다
> 이 간단한 원리를 이용해서 복잡한 시스템을 만든다



## 005 50년 넘게 유지된 무어의 법칙

> **무어의 법칙**
>
> 고든 무어는 기술이 향상됨에 따라 일정한 크기의 집적회로에 들어갈 수 있는 **트랜지스터의 수**가,
> **매년 대략 두배**가 된다고 관측했다 (후에 2년마다 두배로 수정했다)
>
> 트랜지스터의 수는 컴퓨팅 성능을 간접적으로 나타내는 지표이므로,
> 2년마다 컴퓨팅 성능이 두배가 된다는 것을 의미했다
>
> 무어의 법칙은 거의 60년 동안 계속 진행됐고, 이제 집적회로에는
> **1965년에 비해 100만 배가 훨신 넘는 트랜지스터가** 들어있다
>
> 회로의 규모를 특정짓는 대표적인 척도로는 집적회로의 배선 폭, 즉 회로선폭이 사용되고
> (반도체 업계에서는 이를 피처 크기(feature size) 라고도 한다) 회로선폭은 꾸준히 줄어들어왔다
>
> 펩 라인(fabrication line) - 제조 공정
>
> 무어의 법칙은 자연의 법칙이 아니라 반도체 산업에서 목표설정을 위한 일종의 가이드라인이다
> 현재는 무어의 법칙이 적용되고 있지 않다 (많은 이유 중 하나는 칩의 열관리 때문)
> 대신 장착 가능한 코어의 개수가 늘면서 성능이 향상되고 있다



## 006 요약

> 컴퓨터 하드웨어의 기하급수적인 발전이, 우리의 삶을 바꿔놓은 디지털 혁명의 원인이 되었다
>
> 컴퓨터의 성능과 용량의 증가가 사용자의 변화부터 목적의 변화까지 영향을 끼쳤다
>
> 20세기 **컴퓨터과학의 위대한 통찰** 중 하나는 오늘날의 디지털 컴퓨터와 최초의 PC,  원조컴퓨터, 휴대전화, 스마트 기기, 클라우트 서버의 **논리적 속성 또는 기능적 속성은 모두 같다는 사실**이다



## 007 연속과 불연속

이진 숫자 - 비트(bit)

>컴퓨터가 정보를 표현하는 방식

1. 컴퓨터는 디지털 처리 장치이다
   - 즉, 컴퓨터는 불연속적인 덩어리로 입력받고, 불연속적인 값을 갖는 정보를 저장하고 처리한다

2. 컴퓨터는 정보를 비트로 표현한다
   - 비트는 이진 숫자로, 0 또는 1인 수이다
   - 컴퓨터 내부의 모든 것은 십진수가 아닌 비트로 표현된다
3. 비트는 모여서 더 큰 정보를 표현한다
   - 숫자, 문자, 단어, 이름, 소리, 사진, 영화부터 프로그램을 구성하는 명령어까지 모두 비트가 모여 표현된다



### 아날로그와 디지털

> 아날로그(analog)는 유사하다는 뜻의 어원이 있고, 연속적으로 변하는 값이라는 개념을 전달한다
>
> 디지털 시스템은 불연속적인 값을 다루므로 가능한 값의 수가 정해져있다
>
> **컴퓨터의 입장에서는 디지털 데이터가 다루기 쉽다**
>
> 디지털 데이터의 장점
>
> > 저장, 전송, 처리, 압축, 암호화, 병합, 복사, 이동 + 확장성



## 008 아날로그 정보를 디지털로 바꾸기

### 이미지 디지털화 하기

> 사진의 디지털 표현은 계산되어 빛의 강도를 나타내는 수를 배열한 것이다
>
> 검출 소자가 더 많고 전하가 더 정밀하게 측정될수록 디지털화 된 영상이 더 선명하다
>
> RGB검출 소자 세개로 구성되는 센서는 화소(picture element)나 픽셀(pixel)이라고도 한다



### 음향 디지털화 하기

> 바이닐 레코드나 카세트테이프와 달리 디지털 음악은 무료로 **원하는 횟수만큼 복제**가 가능하다
>
> 소리를 시각화 한 기압의 그래프는 아날로그지만, **잘게 쪼개서 디지털 화** 할 수 있다
>
> 변환을 수행하는 장치를 A/D (Analog to Digital) 변환기라 한다
>
> **변환은 결코 완벽하지 않고, 각 방향으로 전환될 때 일부 정보를 잃게 된다**
>
> CD(콤팩트디스크)는 디지털 음향이 소비자에게 전달된 첫 번째 사례였다
>
> LP 레코드의 아날로그 홈 대신 CD는 디스크에 있는 긴 **나선형 트랙에 숫자(비트)를 기록**한다
>
> 소리와 영상은 압축(compression)할 수 있다
>
> 음악은 MP3(MPEG Audio Layer 3)나 AAC(Advanced Audio Coding) 같은 압축기술을,
> 사진은 JPEG(Joint Photographic Experts Group) 압축기술을 사용할 수 있다
> 동영상은 MPEG(Moving Picture Experts Group)로 압축한다



### 영화 디지털화 하기

> 영화는 **이미지를 빠르게 연속해서 보여줌**으로써, 생기는 착시 현상이다
>
> 영화의 디지털 표현은 은향과 영상 요소를 결합하고 동기화 한다



### 텍스트 디지털화하기

> 어떤 종류의 정보는 추가적인 변환 과정 없이 디지털로 어떻게 표현할지 합의하기만 하면 되므로 디지털 변환이 쉽다 (글자가 그렇다)
>
> ASCII (American Standard Code for Information Interchange) 아스키코드가 대표적이다
>
> 전 세계적으론 유니코드(Unicode)라는 단일 표준이 있다
> 유니코드는 모든 언어에 있는 모든 문자에 고유한 숫자 값을 지정한 것이다
> 유니코드에는 14만 개가 넘는 문자가 있고 그 수는 꾸준히 늘고있다
>
> **UTF-8**은 유니코드를 위한 **가변 길이 문자 인코딩 방식** 중 하나
> (Universal Coded Character Set + Transformation Format – 8-bit)
> UTF-8 인코딩은 유니코드 **한 문자를 나타내기 위해 1바이트에서 4바이트까지를 사용**



#### UTF-8

- 장점
  - UTF-8은 모든 [유니코드](https://ko.wikipedia.org/wiki/유니코드) 문자를 표현할 수 있다
  - ASCII 인코딩은 UTF-8의 부분 집합이다. 일반적인 ASCII 문자열은 올바른 UTF-8 문자열이며, 따라서 하위 호환성이 보장된다
  - UTF-8과 UTF-16은 XML (Extensible Markup Language) 문서의 표준 인코딩으로, 다른 인코딩들을 사용하려면 외부에서, 또는 문서 안에서 명시적으로 인코딩을 정해야 한다
  - 다른 인코딩과의 왕복 변환이 간단하다
  - 바이트 단위 문자열 검색 알고리즘들을 그대로 사용할 수 있다
- 단점
  - 한중일 문자들과 표의 문자를 제외한 거의 모든 기존 인코딩들은 한 문자에 1바이트를 사용하므로 문자열 처리가 간편한 반면, UTF-8은 그렇지 않다



## 결론

결론적으로, 디지털 표현은 **숫자 값으로 변환될 수 있는 어떤 것이든 나타낼 수 있고**
**컴퓨터로 처리될 수 있다**
또한 저장, 전송, 처리, 압축, 암호화, 병합, 복사, 이동 + 확장성의 장점을 가진다



## 009 0과 1의 세계

> 이진수 (binary number, 기수가 2인 수)



### 비트 

> bit(binary digit) : 디지털 정보를 표현하는 가장 기본적인 방식, 0과 1만을 사용



## 010 비트 모아 데이터



### 이진수

이진수를 십진수로 표현하는 법

- 각 자리의 수에 2^n 을 곱해 더한다

십진수를 이진수로 표현하는 법

- 십진수를 2로 반복해서 나눠 나머지를 역순으로 기입한다
- 십진수에 포함되는 가장 큰 2^n부터 빼가면서, 0이 될 때까지 뺀다



### 바이트 (byte)

> 모든 최신 컴퓨터의 데이터 처리와 메모리 구성의 기본 단위, **1바이트 == 8비트**
>
> 단일 바이트는 2^8 = 256개의 구별되는 값을 인코딩 할 수 있다
>
> 바이트 **두 개**는 총 16비트이며, 2^16가지 (**65535**)의 값을 나타낼 수 있다
>
> 아스키코드 문자 하나 - 1바이트
>
> 유니코드 문자 하나 - 2바이트

십육진수 (0~9,A,B,C,D,E,F) - 정보의 종류를 나타낸다

어떤 프로그램의 데이터는 다른 프로그램의 명령어가 되기도 한다
프로그램이나 앱을 다운로드할 때 무작정 복사되었던 비트들이,
프로그램을 실행할 때에는 CPU에 의해 처리되면서 명령어로 취급된다



## 011 요약

> 컴퓨터는 왜 십진수가 아닌 이진수를 사용할까?
>
> 물리적인 장치를 만들 때 켜짐과 꺼짐이라는 두 가지 상태만 갖도록 하는 것이
> 열 가지 상태를 갖도록 하는 것보다 훨씬 쉽기 때문이다
>
> 전류(흐름, 흐르지 않음), 전하(존재, 비존재), 자성(N, S), 빛(밝음, 어둠), 반사율(반사율이 높고 낮음)



## 012 프로세서와 계산기의 다른 점

> "기계에 전달된 명령이 숫자형 코드로 변환되고 **기계가 일정한 방식으로 수와 명령을 구분할 수 있다면**, 기억 기관은 수와 명령 둘 다 저장되는 데 사용될 수 있다"
>
> 프로세서는 컴퓨터의 가장 중요한 구성 요소이다



#### 프로세서의 작동

- 산술 연산 (계산기의 산술 기능)
- 메모리에서 연산을 수행 할 데이터를 가져오거나, 연산 결과를 메모리에 저장 (계산기의 메모리 기능)
- 컴퓨터의 나머지 부분을 제어
  - 버스로 전송되는 신호를 통해 마우스, 키보드, 디스플레이, 기타 전기적으로 연결 된 모든 장치에 대한 입력과 출력을 조직화하고 조정한다

- **중요한 점은 프로세서가 비록 단순하긴 해도 결정을 내릴 수 있다는 것이다**
  - 비교 연산 등을 통해 사람의 개입 없이 (독립적으로) 작동하여, 스스로 전체 시스템을 운영할 수 있다



## 013 모형 컴퓨터로 더하기 프로그램 만들기

> 컴퓨터의 작동법을 이해하기 위해, 상상으로 만든 컴퓨터를 '모형 컴퓨터'라고 한다
>
> 모형 컴퓨터에는 명령어와 데이터를 저장하기 위한 메모리가 있고,
> 한개의 수를 담을 만한 용량의 부가적인 저장 영역인 누산기가 있다고 하자
>
> 모형 컴퓨터에는 기본 연산을 수행하기 위한 약 10개의 명령어 레퍼토리가 있다

모형 컴퓨터의 대표적인 명령어

- GET - 키보드에서 수를 입력받은 후 누산기에 넣는다 (누산기의 기존 내용을 덮어쓴다)
- PRINT - 누산기의 내용을 출력한다 (누산기의 내용은 변하지 않는다)
- STORE M - 누산기 내용의 복사본을 메모리 위치 M에 저장한다 (누산기의 내용은 변하지 않는다)
- LOAD M - 메모리 위치 M의 내용을 누산기에 적재한다 (M의 내용은 변하지 않는다)
- ADD M - 메모리 위치 M의 내용을 누산기의 내용에 더한다 (M의 내용은 변하지 않는다)
- STOP - 실행을 중지한다



각 메모리 위치에 한 개의 수 또는 한 개의 명령어가 담겨 있으므로, 프로그램은 메모리에 저장된 일련의 명령어와 데이터 항목으로 구성된다

작동을 시작하면 프로세서는 첫 번째 메모리 위치에서 시작해서 다음과 같이 단순한 사이클을 반복한다

- 인출 Fetch: 메모리에서 다음 명령어를 가져온다
- 해석 Decode : 명령어가 무슨 일을 하는지 알아낸다
- 실행 Excute : 명령어를 실행한다.
- 인출 단계로 되돌아간다



#### 프로세서의 명령 처리

> 프로세서는 프로그램의 처음부터 시작해서 **명령어를 한 번에 한 개씩** 가져온다
> 각 명령어를 **차례차례 실행하고 다음 명령어로 넘어간다** - 레지스터



#### 프로세서의 데이터 저장 방식

> 데이터는 명령어로 해석되지 않을 메모리 공간 어딘가에 저장해 두어야 하는데,
> **데이터 값을 모든 명령어 다음에 오도록 프로그램의 끝에 두면**,
> 프로세서는 절대로 데이터 값을 명령어로 해석하려고 시도하지 않는다 (데이터 값 도달 전에 Stop 한다)



#### 데이터의 위치 파악

> 프로그램의 명령어가 메모리 위치를 필요로 할 때, 그 **메모리 위치를 나타내는 방법**은,
> **데이터 위치에 이름을 부여**하는 것이다



#### 분기 명령어

> 프로세서의 명령어 레퍼토리에 **일련의 명령어를 재사용하게 하는 새로운 종류의 명령어**이다
> 종종 '분기' 또는 '점프'라고 불리는 GOTO 명령어는 바로 다음 명령어가 아니라 GOTO가 지정하는 위치로 이동하여 명령어를 실행하도록 프로세서에 지시한다
>
> GOTO 명령어를 사용하면 **프로세서가 프로그램의 앞부분으로 돌아가서 명령어 처리를 반복**하도록 할 수 있다



##### 조건부 분기 (conditional branch)

> **분기 명령어의 루프를 멈추는 명령어** 조건부 점프 (conditional jump)라고도 한다
>
> 값이 0인지 검사하여, 특정한 명령어로 건너뛰는 명령어이다
>
> False = 0



유사 명령어 - sum:0 (선언 및 초기화 역할)



#### 프로그램 테스트

> **체계적으로 테스트** 하는 것이 중요하다 - 예외 상황이나 특이한 상황을 가정하여 테스트



#### 메모리 내부 표현

> 메모리 위치를 한개 사용하는 GET 같은 명령어도 있고,
> 다른 메모리 위치도 참조하기에 메모리 위치를 두개 사용하는 IFZERO나 ADD같은 명령어도 있다



## 014 프로세서는 무조건 빠른게 좋을까?

> 프로세서는 인출, 해석, 실행 사이클을 계속 반복 수행한다
>
> 1. 메모리에서 다음에 처리할 명령어를 인출한다
> 2. 가져온 명령어를 해석한다
> 3. 명령어를 실행한다
> 4. 다시 1의 인출단계로 돌아간다

컴퓨터 아키텍처는 **프로세서 설계**와 더불어 **프로세서와 컴퓨터 나머지 부분 간의 연결 방식 설계**를 다루는 분야다컴퓨터 아키텍처 분야의 주요 관심사 중 하나는 명령어 집합(instruction set)이고, 이 명령어 레파토리의 종류와 속도, 편의성 등등은 트레이드 오프 관계이다
**컴퓨터 아키텍처는 기능성, 속도, 복잡도, 전력 소모 정도, 프로그램 가능성 등 상충하는 요구 간 복잡한 트레이드 오프(trade off)를 수반한다**

현대 컴퓨터 아키텍처는 **캐시(cache)라는 고속 메모리**를 몇 개 사용한다
캐시는 프로세서와 메모리 사이에 있고, 최근 사용된 명령어와 데이터를 담고 있다

프로세서가 더 빨리 작동하도록 만들기 위해 여러가지 아키텍처 기법을 동원한다
그 중 하나가 인출과 실행 단계가 겹치도록 프로세서를 설계해서 명령어 여러 개가 다양한 단계에 걸쳐 진행되도록 만드는 것이고, 이를 **파이프라이닝**이라 한다. 또 다른 기법은 명령어들이 서로 간섭하거나 의존하지 않는다면 다수의 명령어를 **병렬**적으로 **실행**하는 방법이다

그 밖에도 프로세서 여러 개가 동시에 작업하도록 하는 기법이 있고, 이는 노트북과 휴대폰에서 표준으로 사용한다

사용 분야에 따라 프로세서를 설계할 때 다양한 종류의 트레이드오프가 이뤄지고, 프로세서의 속도 뿐만 아니라 다양한 기능적 특성을 고려한다. 그러므로 **어떤 프로세서가 다른 것보다 '빠르다'는 주장은 조심스럽게 받아들여야 한다**. 요구사항에 따라 차이가 있을 수 있다

누산기 = 레지스터

> 컴퓨터의 중앙 처리 장치(CPU)에서 중간 산술 논리 장치 결과가 저장되는 레지스터
>
> [레지스터](https://ko.wikipedia.org/wiki/레지스터)가 없으면 다음 연산을 위해 다시 읽을 수 있도록 각각의 계산(더하기, 곱하기, [시프트](https://ko.wikipedia.org/wiki/비트_연산) 등)의 결과를 주 기억장치에 기록할 필요가 있다. 주 기억장치에 대한 접근은 누산기와 같은 레지스터에 접근하는 것 보다 더 느린데, 이는 대형 주 메모리에 사용되는 기술이 레지스터에 사용되는 것 보다 더 느리기(그러나 값은 더 저렴함) 때문이다.
>
> 현대의 컴퓨터 시스템들은 종종 누산기의 역할을 하는 여러 개의 범용 레지스터를 갖추고 있으므로 이 용어는 더 이상 과거처럼 일상적으로 쓰이지 않는다.



## 015 캐시가 뭐가요?

> "그러므로 우리는 메모리를 계층 구조로 만들 가능성이 있음을 결국 인식하게 된다. 여기서 **각 단계의 메모리는 앞 단계**보다 **용량은 더 크고** 접근 **속도는 느리다**"

> 프로세서에서 **캐시는 용량이 작고 속도가 빠른 메모리**로, 용량이 더 크지만 훨씬 느린 
> **주 기억 장치에 매번 접근하는 것을 피하고자 최근에 사용된 정보를 저장**하는 데 사용된다
>
> 일반적인 프로세서에는 캐시가 2~3개 있는데, 흔히 L1, L2, L3레벨이라고 부르고 뒤로 갈수록 용량은 크지만 속도는 더 느리다 (L1이 가장 빠르고 L3가 가장 느림)

#### 캐싱

>**캐시 영역으로 데이터를 가져와서 접근하는 방식**
>
>우리가 뭔가를 사용하고 있고 그것을 **곧 다시 쓸 가능성(시간적 지역성)**이 있거나 **근처에 있는 뭔가를 사용할 가능성(공간적 지역성)**이 있을 때 언제든지 활용할 수 있는 훨씬 더 일반적인 개념이다
>
>캐싱이 효과적인 이유는 최근에 사용된 정보가 곧 다시 사용될 가능성이 크기 때문이다
>캐시는 연속된 메모리 위치를 포함한 데이터 블록을 불러오는 데, 이는 인접한 정보가 사용될 가능성이 높기 때문이다



#### 캐시의 관리

> 웹 브라우저에서 '캐시를 삭제한다'라는 문장을 본 적 있을 것이다
> 브라우저는 어떤 웹페이지에 포함된 이미지나 **비교적 용량이 큰 다른 데이터의 로컬 사본**을 유지하고 있다
> 단, 캐시의 용량은 한정돼 있으므로 브라우저는 오래된 항목부터 자동으로 제거한다 (수동삭제도 가능하다)
>
> 워드나 엑셀같은 프로그램에 있는 최근에 사용된 파일 목록도 일종의 캐싱이다





# 소프트웨어

# 통신



## 079 곳곳에 도사리는 위험

> 웹은 상당수의 복잡한 보안 문제를 제기한다
>
> 보안 위협은 대체로 세 가지 범주로 나뉜다
>
> - 클라이언트 공격
> - 서버 공격
> - 전송 중인 정보 공격 (무선 통신 스누핑, NSA가 광케이블상의 모든 트래픽 탈취)



### 클라이언트 공격
# 알고리즘 2주차 문제풀이



## 1일 차 - BFS

- 조합의 합 (leetcode no.39)

> DFS로 풀이 - 중복을 허용했으므로 DFS가 유리하다

```python
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        result = []
        ## csum을 target에서 뽑은 숫자들을 빼는 것으로 정의하는게 쉽게 푸는 포인트
        def dfs(csum, index, path):
            if csum<0:
                return
            if csum == 0:
                result.append(path)
                return
            for idx in range(index,len(candidates)):
                dfs(csum-candidates[idx], idx, path+[candidates[idx]])
        dfs(target,0,[])
        return result
```



- 부분 집합 (leetcode no.78)

```python
    def subsets(self, nums: List[int]) -> List[List[int]]:
        result = []
        def bfs(idx,path):
            result.append(path)
            for i in range(idx,len(nums)):
                bfs(i+1,path+[nums[i]])

        bfs(0,[])
        return result
```



- 일정 재구성 (leetcode no.332)

```python
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        path = []
        graph = collections.defaultdict(list)
        ##(사전 순으로 정렬 한) 티켓리스트를 {key:value}가 {from:to}인 딕셔너리를 만든다
        for a, b in sorted(tickets):
            graph[a].append(b)

        def dfs(start):
            ## 첫 번째 값을 읽어 어휘 순 방문
            while graph[start]:
                ## pop(0)으로 사전 어휘순으로 방문한다
                ## 방문이 결정된 티켓을 없애고, 도착지를 dfs에 넣는다
                dfs(graph[start].pop(0))
            ## DFS이기 때문에 출발값이 제일 나중에 append된다 (순서를 reverse 시켜줘야 한다)
            path.append(start)

        dfs('JFK')
        print(path)
        return path[::-1]
```




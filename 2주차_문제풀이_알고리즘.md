# 알고리즘 2주차 문제풀이



## 1일 차 - BFS

- 조합의 합 (leetcode no.39)

> DFS로 풀이 - 중복을 허용했으므로 DFS가 유리하다

```python
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        result = []
        ## csum을 target에서 뽑은 숫자들을 빼는 것으로 정의하는게 쉽게 푸는 포인트
        def dfs(csum, index, path):
            if csum<0:
                return
            if csum == 0:
                result.append(path)
                return
            for idx in range(index,len(candidates)):
                dfs(csum-candidates[idx], idx, path+[candidates[idx]])
        dfs(target,0,[])
        return result
```



- 부분 집합 (leetcode no.78)

```python
    def subsets(self, nums: List[int]) -> List[List[int]]:
        result = []
        def bfs(idx,path):
            result.append(path)
            for i in range(idx,len(nums)):
                bfs(i+1,path+[nums[i]])

        bfs(0,[])
        return result
```



- 일정 재구성 (leetcode no.332)

```python
    def findItinerary(self, tickets: List[List[str]]) -> List[str]:
        path = []
        graph = collections.defaultdict(list)
        ##(사전 순으로 정렬 한) 티켓리스트를 {key:value}가 {from:to}인 딕셔너리를 만든다
        for a, b in sorted(tickets):
            graph[a].append(b)

        def dfs(start):
            ## 첫 번째 값을 읽어 어휘 순 방문
            while graph[start]:
                ## pop(0)으로 사전 어휘순으로 방문한다
                ## 방문이 결정된 티켓을 없애고, 도착지를 dfs에 넣는다
                dfs(graph[start].pop(0))
            ## DFS이기 때문에 출발값이 제일 나중에 append된다 (순서를 reverse 시켜줘야 한다)
            path.append(start)

        dfs('JFK')
        print(path)
        return path[::-1]
```



- 코스 스케줄 (leetcode no.207)

```python
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        graph = collections.defaultdict(list)
        for a,b in prerequisites:
            graph[a].append(b)
            #>>> graph = {0:[1,2], 1:[2]}

            traced = set()
            def dfs(i):
                ## 순환구조이면 False
                #> 조건1 if 0실행, 조건2 if 1 대기
                if i in traced:
                    return False

                ## traced에 i를 넣고
                #> 조건1 if 0실행 : traced = {0}
                #>> 재귀1 dfs(1) 실행 : traced = {0,1}
                traced.add(i)

                ## i를 완료하기 위해 끝내야하는 것들을 dfs에 넣어 재귀로 테스트 해본다
                #> 조건1 if 0실행 : graph[0] == [1,2]
                #>> 재귀1 dfs(1) 실행 : graph[1] = [2]
                for y in graph[i]:
                    #>> 조건1 if 0실행 : dfs(1)실행 <- 재귀1, dfs(2)대기
                    #>> 재귀1 dfs(1) 실행 : y==2 , dfs(2)실행 <- 재귀2
                    if not dfs(y):
                        return False

			## 탐색 종료 후 순환노드 i 삭제
            traced.remove(i)
            return True

	## 순환 구조 판별
    ## graph의 key들을 dfs에 넣어본다
    #>>> 0, 1
    for x in list(graph):
        if not dfs(x):
            return False

        return True

```



- DFS와 BFS (백준 no.1260)





## 2일 차 - 백트래킹

- 1,2,3 더하기 (백준 no.9095)

```python
import sys

class Solution:
    def beakjoon9095(self):
        test_case = int(sys.stdin.readline())

        result = []
        def dfs(minus,path):
            if minus==0:
                result.append(path)
                return
            if minus<0:
                return
            for i in range(1,4):
                dfs(minus-i,path+[i])

        for i in range(test_case):
            numPerLine = int(sys.stdin.readline())
            dfs(numPerLine, [])
            print(len(result))
            result.clear()

sol = Solution()
sol.beakjoon9095()

## 다른방법 - 주어진 값이 x일 때의 결과 : (x-3)의 결과와 (x-2)의 결과 (x-1)의 결과를 더한 것
"""
n이 1,2,3 일때 이후부터는 앞의 세개의 결과값을 더한것이다
ex) n이 4일때는 n1,n2,n3의 결과값의 합
ex) n이 10일때는 n7,n8,n9의 결과값의 합
"""
```





- 암호 만들기 (백준 no.1759)

```python
import sys

class Solution:
    def beakjoon1759(self):
        l, c = list(map(int, sys.stdin.readline().split()))
        alpa = list(map(str, sys.stdin.readline().split()))
        mo = ['a', 'e', 'i', 'o', 'u']

        result = []

        def dfs(idx, path):
            if len(path) == l:
                # result.append(sorted(path))
                include = False
                for m in mo:
                    if m in path:
                        include = True
                        break
                if include:
                    result.append(sorted(path))
                    return

            for i in range(idx, c):
                dfs(i + 1, path + [alpa[i]])

        dfs(0, [])
        #print(result)
        return result

sol = Solution()
sol.beakjoon1759()
```












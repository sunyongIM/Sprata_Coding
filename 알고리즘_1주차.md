> <파이썬 알고리즘 인터뷰> [책만]
>
> [[스파르타코딩클럽\] 파이썬 문법 뽀개기 (notion.so)](https://www.notion.so/dfb89a042c6f4b29b64ea4da03a37ea6#9e45965f552e4768b295f003bc5a3436)

# 1주차



## 파이썬 문법 공부



### 인덴트 [Indent]

> 들여쓰기 - 공백 4칸을 기준으로 하고 행간의 구별 뿐 아니라 코드를 구분해준다



### 네이밍 컨벤션

> `_`를 사용하는 스네이크 케이스를 따른다



### 타입 힌트

> 동적 타이핑 언어임에도 타입을 선언할 수 있는 방식

```python
	a: str = "1"
    a: int = 1
```



### 리스트 컴프리헨션

> 파이썬의 매우 강력한 기능 중 하나이고, 파이썬을 대표하는 특징 중 하나이다
>
> map, filter와 같은 함수형 기능을 지원하며, 람다 표현식 [ Lambda Expression ] 도 지원한다

- 람다 표현식 (익명 함수)
- 람다 표현식 안에서는 새 변수를 만들 수 없어서, 반환값 부분은 변수 없이 식 한 줄로 표현할 수 있어야 한다

```python
## 기존의 함수
def plus_ten(x):
return x + 10
plus_ten(1)
11

## 람다 표현식
plus_ten = lambda x: x + 10
plus_ten(1)
11
```



### 제너레이터

> 루프의 반복 동작을 제어할 수 있는 루틴 형태를 말한다
>
> yield 구문을 사용해서 루프의 종료없이 값을 양보(리턴)받을 수 있다



### _ (언더바)의 쓰임

- 인터프리터에서 마지막 값을 저장할 때
- **값을 무시하고 싶을 때 (흔히 "I don't care"라고 부른다)**
- 변수나 함수명에 특별한 의미 또는 기능을 부여하고자 할 때
- 국제화/지역화 함수로써 사용할 때
- 숫자 리터럴값의 자릿수 구분을 위한 구분자로써 사용할 때



### range

> 제너레이터 방식을 활용하는 대표적인 함수이고, 주로 for 문에서 쓰인다
>
> 미리 생성한 리스트와 달리 range 함수를 사용하면 메모리를 아낄 수 있다

```python
a = [n for n in range(1000000)]
b = range(1000000)
sys.getsizeof(a)
>>> 8697464
sys.getsizeof(b)
>>> 48
```



### print

> 실무에서는 print를 활용한 디버깅을 추천하지 않지만, 코딩테스트에서는 주로 유일한 디버깅 방법이기 때문에 잘 쓸 줄 알아야한다

```python
print('a1','b1')
>>> a1 b1		## 콤마로 구분하면 한칸 공백이 디폴트이다

print('a1','b1',sep=',')
>>> a1,b1

## 프린트 함수는 항상 줄바꿈을 한다.
## 아래는 긴 루프의 값을 반복적으로 처리할때 한줄로 나타내는 방법
print('a1', end='')
print('b1')
>>> a1 b1

## 리스트를 출력할 때는 join()으로 묶어서 처리한다
a = ['a1', 'b1']
print(''.join(a))
>>> a1 b1

## 프린트 시 {}로 미리 위치를 지정해 놓고 .format()으로 지정된 위치에 순서대로 출력한다
a, b = 'a1', 'b1'
print("{},{}".format(a,b))
>>> a1 b1
```



### pass

> 널 연산으로 아무것도 하지 않는 기능이지만, 구현하지 못 한 함수의 indent 오류를 지나쳐준다



### locals

> locals()는 로컬 심볼 테이블 딕셔너리를 가져오는 메소드이다
> 로컬에 선언된 모든 변수를 조회할 수 있는 강력한 명령으로, 디버깅에 도움이 많이 된다

```python
import pprint
pprint.pprint(locals())
## pprint로 출력하게 되면 보기 좋게 줄바꿈 처리를 해주기 때문에 가독성이 높다
>>> {변수 : 값,
    변수 : 값}
```



### 구글 파이썬 스타일 가이드

> 함수의 기본값으로 가변 객체 (Mutable Object)를 사용하지 않아야 한다. - EX) list, dict, set
> 함수가 객체를 수정하면 기본값이 변경되기 때문이다.
>
> 대신에 None과 같은 불변 객체 (Immutable Object)를 할당 해야한다.

```python
import this ## 파이썬 철학이 나온다
```





## 1회차 - 알고리즘 개요

> [1회차 알고리즘 개요 (notion.site)](https://teamsparta.notion.site/1-eed263c144bf4d9fb9866cc668c1b977)

- 문제

  <aside> ❓ Q. 다음과 같이 숫자로 이루어진 배열이 있을 때, 이 배열 내에서 가장 큰 수를 반환하시오.</aside>

  ```python
  [3, 5, 6, 1, 2, 4]
  ```

- 생각해보기

  - 1억 개라면?

    - 시간복잡도를 낮추는 알고리즘을 이용
      - **반복문 중첩이 적을수록 좋다!!**

  - 메모장이 작다면?

    - 공간복잡도를 낮추는 알고리즘을 이용

      - 메모리 공간을 적게 쓸수록 좋다

      > (공간복잡도는 C언어나 임베디드쪽이 아니면 크게 신경 안써도 됨)



- 최빈값 찾기

  - Q. 문제 설명

    <aside> ❓ Q.  다음과 같은 문자열을 입력받았을 때, 어떤 알파벳이 가장 많이 포함되어 있는지 반환하시오</aside>

    ```python
    "hello my name is sparta"
    ```

  - Answer

```python
import string
## pprint - prety print 더 예쁘게 출력됨
from pprint import pprint

text = 'hello, this is sparta'

counter = {}
# 21 번 연산
for char in text:
    if not char.isalpha():
        continue
    if char in counter:
        counter[char] += 1
    else:
        counter[char] = 1
pprint(counter)
```

### 점근 표기법

> 알고리즘의 성능을 수학적으로 표기하는 방법입니다. 알고리즘의 “효율성”을 평가하는 방법입니다.

```HTML
점근 표기법의 종류에는 
빅오(Big-O)표기법, 빅오메가(Big-Ω) 표기법이 있습니다.

빅오 표기법은 최악의 성능이 나올 때 어느 정도의 연산량이 걸릴것인지,
빅오메가 표기법은 최선의 성능이 나올 때 어느 정도의 연산량이 걸릴것인지에 대해 표기합니다.

예를 들어 
빅오 표기법으로 표시하면 $O(N)$,
빅 오메가 표기법으로 표시하면 $Ω(1)$ 의 시간복잡도를 가진 알고리즘이다
```

> (빅 오메가 거의 안씀)



### 빅오(O)

> 빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 **상한**을 나타낸다
>
> 특히 가장 늦게 실행될 때를 **빅오(O)**라고 한다 **(최악의 경우의 상한)**



### 분할 상환 분석

> 시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때, 알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유로 생겨났다
>
> 최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산할 수 있다
> 유용함 덕분에 최근에는 시간 복잡도를 계산할 때 매우 보편적으로 널리 사용된다



### 병렬화

> 일부 알고리즘들은 병렬화로 실행 속도를 높일 수 있다
>
> GPU가 병렬 연산을 위한 대표적인 장치이다
> GPU의 각각의 코어는 CPU의 코어보다 느리지만, 개수가 많기 때문에 GPU를 사용하여 병렬연산을 할 수 있는 알고리즘은 속도가 빠르고 우수하다고 평가받는다



#### 문제) 알파벳 찾기

> [10809번: 알파벳 찾기 (acmicpc.net)](https://www.acmicpc.net/problem/10809)

- `ord()` - 문자를 아스키 코드로 바꿔줌
  - ord(a) => 97
- `chr()` - 아스키 코드를 문자로 바꿔줌
  - chr(97) => a
- `string.ascii_lowercase` - a~z까지 26개의 알파벳 반환
  - `len(string.ascii_lowercase)`으로 26을 구할 수 있다 (불필요하다 생각해서 쓰지않았다)

```python
#내 풀이
def find(word):
    result = [-1]*26
    for i in range(len(word)):
        char = word[i]
        num = ord(char)
        if result[num-97]==-1:
            result[num-97] = i
    #print(result)
    #int를 char로 바꾸고 공백(' ')을 추가해서 프린트
    print(' '.join([str(num) for num in result]))

find('baekjoon')
```

> 접근
>
> 1. 어떤 알파벳이 단어에 포함되지 않는다면 -1을 출력하므로 default값이 [-1]*26 배열
> 2. 주어진 word의 char만 확인하고 그것을 배열에 적용시킨다
> 3. 알파벳은 `ascii code`에서 하나씩 커진다
> 4. 배열의 시작인 a의 `ascii code`가 97이므로 배열의 알파벳과 ord(char)-97 인덱스가 매칭된다
> 5. 한번만 넣어야 하므로 if문으로 해당 위치의 값이 -1인지 확인한다
> 6. 해당 인덱스에 word의 인덱스 i값을 넣는다



### 동적배열

> 크기가 고정되지 않은 배열
>
> 파이썬 리스트의 가장 좋음 점은 매우 다양한 기능을 제공한다는 점이다
> 리스트를 사용하면 사실상 스택을 사용할지, 큐를 사용할지를 고민하지 않아도 되며,
> 스택과 큐에서 사용 가능한 모든 연산을 함께 제공한다

### 시간복잡도

빅오가 O(1)인 기능

- `len(리스트)`
  - 전체 요소의 개수 리턴 
- `a[i]`
  - 인덱스 i의 요소 가져오기 
- `.append()`
  - 리스트 마지막에 요소 추가 
- `.pop()`
  - 리스트 마지막 요소 추출 

빅오가 O(n)인 기능

- `ele in 리스트`
  - ele 요소 존재여부 확인
- `.count(ele)`
  - ele 요소의 개수를 리턴
- `.index(ele)`
  -  ele 요소의 인덱스를 리턴한다
- `.pop(0)`
  - 첫 번째 요소를 추출 
- `del 리스트[i]`
  - i 인덱스의 값 삭제
- `min(리스트)`,`max(리스트)`
  - 최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다
- `리스트.reverse()`
  - 뒤집는다

빅오가 O(nlogn)인 기능

- `.sort`
  - 정렬한다



> https://wayhome25.github.io/python/2017/06/14/time-complexity/

#### list

| Operation     | Example         | Big-O      | Notes                     |
| :------------ | :-------------- | :--------- | :------------------------ |
| Index         | l[i]            | O(1)       |                           |
| Store         | l[i] = 0        | O(1)       |                           |
| Length        | len(l)          | O(1)       |                           |
| Append        | l.append(5)     | O(1)       |                           |
| Pop           | l.pop()         | O(1)       | l.pop(-1) 과 동일         |
| Clear         | l.clear()       | O(1)       | l = [] 과 유사            |
| Slice         | l[a:b]          | O(b-a)     | l[:] : O(len(l)-0) = O(N) |
| Extend        | l.extend(…)     | O(len(…))  | 확장 길이에 따라          |
| Construction  | list(…)         | O(len(…))  | 요소 길이에 따라          |
| check ==, !=  | l1 == l2        | O(N)       | 비교                      |
| Insert        | ㅣ.insert(i, v) | O(N)       | i 위치에 v를 추가         |
| Delete        | del l[i]        | O(N)       |                           |
| Remove        | l.remove(…)     | O(N)       |                           |
| Containment   | x in/not in l   | O(N)       | 검색                      |
| Copy          | l.copy()        | O(N)       | l[:] 과 동일 - O(N)       |
| Pop           | l.pop(i)        | O(N)       | l.pop(0):O(N)             |
| Extreme value | min(l)/max(l)   | O(N)       | 검색                      |
| Reverse       | l.reverse()     | O(N)       | 그대로 반대로             |
| Iteration     | for v in l:     | O(N)       |                           |
| Sort          | l.sort()        | O(N Log N) |                           |
| Multiply      | k*l             | O(k N)     | [1,2,3] * 3 » O(N**2)     |

#### Dict

| Operation      | Example     | Big-O     | Notes                   |
| :------------- | :---------- | :-------- | :---------------------- |
| Index          | d[k]        | O(1)      |                         |
| Store          | d[k] = v    | O(1)      |                         |
| Length         | len(d)      | O(1)      |                         |
| Delete         | del d[k]    | O(1)      |                         |
| get/setdefault | d.method    | O(1)      |                         |
| Pop            | d.pop(k)    | O(1)      |                         |
| Pop item       | d.popitem() | O(1)      |                         |
| Clear          | d.clear()   | O(1)      | s = {} or = dict() 유사 |
| View           | d.keys()    | O(1)      | d.values() 동일         |
| Construction   | dict(…)     | O(len(…)) |                         |
| Iteration      | for k in d: | O(N)      |                         |



### 내장함수

- 리스트와 문자열 관련

#### 슬라이싱 **`[start:end:step]`** - 리스트+문자열

> 파이썬에는 슬라이싱 [ slicing ] 간결하고 강력한 기능이 있다
> **따라서 문자열이나 리스트에서 슬라이싱은 많이 활용하자**
>
> b>a일때 `리스트 또는 문자열`[a:b] 로 슬라이싱을 한다면 슬라이싱 된 값의 개수는 **b-a-1개**이다
> 이것은 **인덱스 b의 값이 슬라이싱 된 값에 포함되지 않기** 때문에 발생된다
> 자주 헷갈리니 조심해야 한다
>
> step이 음수일 경우에는 index가 큰수에서 작아진다 (카운트다운)

- ex) 인덱스 1에서 인덱스 3 **이전**까지 값을 가져오기
  - `리스트[1:3]`
  - `문자열[1:3]`

> 세번째 파라미터(step) 활용 - step만큼 건너뛰기

- 인덱스1에서 10이전까지 홀수번째 (**step씩 건너**뛰어) 인덱스의 값을 가져오기
  - `리스트[1:10:2]`

- 뒤집기
  - `리스트[::-1]`

![python_index_with_negative](md-images/python_index_with_negative.png)

> **파이썬에서 음수 인덱스를 사용 할 일이 많으므로 익숙해지자**



#### delete, remove, pop - 리스트

> delete - index로 삭제하기, remove - 값으로 삭제하기, pop - 값 반환 + 삭제

- `del 리스트[i]`
  - index가 i인 값을 삭제한다
- `리스트.remove(값)`
  - 값에 해당하는 요소 삭제
- `리스트.pop(i)`
  - index가 i인 값을 삭제하고 반환



#### .join() - 리스트

> **''.join(리스트)**
>
> **'구분자'.join(리스트)**

- 리스트를 문자열로 만들어주는 기능
- 구분자가 있는 경우 문자열 사이에 구분자가 들어간다
- **`''.join(리스트)`** <== 많이쓴다



#### sorted() - 리스트 + 문자열

- `sorted(문자열)`
  - 문자열과 리스트의 **정렬 결과를 list로 리턴**
  - list타입 정렬 결과를 다시 조립할 때 `''.join(리스트)` 사용
- `sorted(리스트)`
  - 리스트를 **정렬해 list로 리턴**

#### .sort() - 리스트 + 문자열

> sorted()와는 다르게 sort()는 **리스트 자체를 제자리 정렬**하기에 **리턴값이 없다**

- `리스트.sort()`
  - 리스트 자체를 정렬하여 정렬된 값으로 덮어씌운다

##### sort 정렬방법

> sort()와 sorted() 모두 `key=len`과 같이 key= 로 정렬 옵션을 지정해 줄 수 있다



#### `range(start:end:step)`

> java의 `for(int i=0; i<end; i++)` 와 비슷한 역할을 한다
>
> **슬라이싱과 사용법이 거의 같다**
>
> step으로 음수를 지정할 수 있다 (step이 음수면 **카운트다운**)



### 백트래킹

> 모든 경우의 수를 전부 고려하는 [알고리즘](https://namu.wiki/w/알고리즘). 상태공간을 트리로 나타낼 수 있을 때 적합한 방식이다. 일종의 트리 탐색 알고리즘이라고 봐도 된다. 방식에 따라서 깊이우선탐색(Depth First Search, DFS)과 너비우선탐색(Breadth First Search, BFS), 최선 우선 탐색(Best First Search/Heuristic Search)이 있다. 그냥 뇌없이 짤 수 있다는 것이 장점이다.
>
> 모든 경우의 수를 고려해야 하는 문제라면[[1\]](https://namu.wiki/w/백트래킹#fn-1), DFS가 낫다. BFS로도 구현이 물론 가능하지만, BFS로 구현했다간 큐의 크기가(...). 심지어 속도도 똑같다. 따라서 경우의 수 구하기는 일반적으로 DFS가 편리하다. 대다수의 문제들은 DFS를 써도 일단 답은 나온다.
>
> 그러나 DFS를 절대 쓰면 안되는 경우가 있는데, 트리의 깊이가 무한대가 될 때이다. 미로찾기에서 루프(회로)가 발생하는 경우, DFS는 이 가지를 탈출할 수 없게 된다. 물론 중복검사를 막기 위한 장치를 넣을 수도 있지만, 그럴 바에는 BFS가 편하다. 또 분기점 없이 길이만 죽어라 긴 길이 나타나면 [스택 오버플로우](https://namu.wiki/w/스택 오버플로우)가 발생할 수 있다. 위의 미로찾기도 4방향(또는 8방향)중 마지막으로 진입하는 방향으로만 갔을 때 도착점이 있다거나 하면 DFS는 느리다. 그리고 최단거리 구하기에서는 BFS를 사용하는게 편리하다.
>
> DFS는 상태공간을 나타낸 트리에서 바닥에 도달할 때까지 한 쪽 방향으로만 내려가는 방식이다. 미로찾기를 생각하면 쉽다. 한 방향으로 들어갔다가 막다른 길에 다다르면(=트리의 바닥에 도착) 왔던 길을 돌아가서 다른 방향으로 간다. 이 짓을 목표지점(=원하는 해)이 나올 때까지 반복한다.
> 재귀함수로 구현할 수 있으며, 재귀함수에 익숙하지 않다면 [스택](https://namu.wiki/w/스택)을 써서 할 수도 있다.
>
> BFS는 모든 분기점을 다 검사하면서 진행하는 방식이다. 철수와 영희가 계단에서 가위바위보를 하며 게임을 하고 있을 때, 철수가 원하는 지점에 갈 수 있는 최소 승리 횟수는 얼마인가? 같은 문제에서 효과를 발휘한다. 이 경우 DFS는 깊이가 무한인 경우에 빠져나오지 못하며, 중복 방지를 한다고 치더라도 올바른 해를 찾는데 시간이 많이 걸린다. BFS는 모든 분기를 다 검색하면서 상태공간을 탐색한다. 철수가 이겼을 때, 비겼을 때, 졌을 때를 검사하고, 그 경우마다 각각 또다른 3가지 가능성을 전부 검사한다. 이러다가 어느 한 부분에서 원하는 해를 발견하면, 이것이 최단 거리가 된다.
>
> BFS는 [큐](https://namu.wiki/w/큐(자료구조))를 써서 구현한다. 각 경우를 검사하면서 발생하는 새로운 경우를 큐에 집어넣고, 검사한 원소는 큐에서 뺀다. BFS의 장점은 DFS가 못 건드리는 문제를 풀 수 있는 것이지만, 공간 복잡도가 지수 스케일로 폭발하기 때문에 가지치기를 제대로 안하면 DFS보다 빨리 오버플로우에 다다를 수 있다.

### 파이썬 문법 2



#### 다중할당

```python
one, two = 1, 2
```



#### 함수 사용법

```python
def funName(x: str, y: float = 6.5) -> int:		##type hinting
    return x + y

value = funName(3)
print(value)
```

> **함수명 : def 다음에 나와있는 funName**
>
> **`x : str` - 콜론(:) 다음에 적어주는 것은 매개변수에 할당되는 형식을 말한다.**
>
> **`y : float = 6.5` - 초기값을 콜론다음에 해당 형식 뒤에 = 하고 값을 적어줄 수 있다. (변수 : 형식 = 기본값)**
>
> **`-> int :` - 이 함수가 반환해주는 값의 형식이 int라는 것을 말한다!** (type hinting)



#### if문 - 삼항연산자

> `(참일 때 값) if (조건) else (거짓일 때 값)`으로 항이 3개라 삼항 연산자

```python
num = 3
result = "짝수" if num%2 == 0 else "홀수"
print(f"{num}은 {result}입니다.")
```



### for in 과 enumerate

> https://wikidocs.net/16045

- iterable 하지 않은 타입
  - int
  - float
  - None
  - char

- dictionary의 for문은 key값만 출력된다
  - (당연하다 dictionary는 key로 값을 찾으면 되지만, 값으로는 정확한 정보를 얻지 못한다)



#### enumerate

> 반복문 사용 시 몇 번째 반복문인지 확인이 필요할 때 사용한다
>
> 인덱스 번호와 컬렉션의 원소를 tuple형태로 반환합니다

```python
t = [1, 5, 7, 33, 39, 52]
for p in enumerate(t):
print(p)
... 
(0, 1)
(1, 5)
(2, 7)
(3, 33)
(4, 39)
(5, 52)
```

> tuple형태 반환을 이용하여 아래처럼 활용할 수 있습니다

```python
for i, v in enumerate(t):
## 프린트 시 {}로 미리 위치를 지정해 놓고 .format()으로 지정된 위치에 순서대로 출력한다
print("index : {}, value: {}".format(i,v))
... 
index : 0, value: 1
index : 1, value: 5
index : 2, value: 7
index : 3, value: 33
index : 4, value: 39
index : 5, value: 52
```



#### for문 - 한방에 써버리기

> [원하는값(temp) for temp in 리스트]

```python
a_list  = [1, 3, 2, 5, 1, 2]

b_list = [a*2 for a in a_list]

print(b_list)
```



#### ***self 이해하기

> https://wikidocs.net/1742
>
> 파이썬 메서드의 첫 번째 인자로 항상 인스턴스가 전달되기 때문에 발생하는 문제
> self가 인자로 있는 메소드는 인스턴스를 이용할 수 있고
> self가 인자로 없는 메소드는 클래스 자체를 이용해야한다

```python
class example:
    def test1(this, arg:int) -> str:
        return f'테스트1 {arg}'
    def test2(arg:int) -> str:
        return f'테스트2 {arg}'


result1 = example()
print(result1.test1(arg=12))
#### this인자가 있는 메소드를 사용할 땐 객체 result1을 class로 인스턴스화 시켜 사용한다

result2 = example.test2(arg=54)
print(result2)
#### this인자가 없는 메소드는 인스턴스를 통해 호출할 수 없는 대신 파이썬의 클래스는
#### 그 자체가 하나의 네임스페이스이기 때문에, 인스턴스 생성과 관계없이 클래스 내의 메서드를 직접 호출할 수 있다

## 에러코드 ##
# result1 = example.test1(arg=12)		# self 위치에 (인스턴스)인자를 전달해야함

# result2 = example()
# print(result2.test2(arg=54))		# self 파라미터가 없는데 (인스턴스)인자가 전달됨
```





## 2회차 - 8장 연결 리스트

> **[ Linked List ]**



![Array_VS_LinkedList](md-images/Array_VS_LinkedList.png)

|       기능       |                            Array                             |                         LinkedList                          |
| :--------------: | :----------------------------------------------------------: | :---------------------------------------------------------: |
|  특정 원소 조회  |                             O(1)                             |                            O(N)                             |
| 중간에 삽입 삭제 |                             O(N)                             |                            O(1)                             |
|   데이터 추가    | 데이터 추가 시 모든 공간이 다 차버렸다면, 새로운 메모리 공간을 할당 받아야한다 | 모든 공간이 다 찼어도 맨 뒤의 노드만 동적으로 추가하면 된다 |
|       정리       |     데이터에 접근하는 경우가 빈번하다면 Array를 사용하자     |  삽입과 삭제가 빈번하다면 LinkedList를 사용하는게 더 좋다   |



```python
class Person:
    def __init__(self, name):
        self.name = name

    def sayhello(self, to):
        print(f"hello {to}, I'm {self.name}")

rtan = Person("rtanny")
rtan.sayhello("hanghae")
```



## 3회차 - 9장 스택

> LIFO [ Last In First Out ] 자료 구조로 나중에 들어간 데이터가 가장 먼저 나온다
>
> Ex) 컴퓨터의 되돌리기(Ctrl + Z) 기능

![Stack_structure](md-images/Stack_structure.png)

스택도 연결 리스트와 노드의 작동방식이 비슷하기에, 같은 노드가 필요하다

```python
class Node:
    def __init__(self, item, next):
        self.item = item
        self.next = next
        
class Stack:
    def __init__(self):
        self.top = None

    ## 푸쉬 - 넣기
    def push(self, value):
        ## 새로 푸쉬된 노드는 기존의 탑 노드를 가리켜야한다
        self.top = Node(item, self.top)

    ## 팝 - 꺼내기
    def pop(self):
        if self.top is None:
            return None

        node = self.top
        ## 기존의 탑 노드를 가리키고 있는 top.next를 사용해 탑을 교체한다
        self.top = self.top.next

        return node.item
	
    ## 픽 - 탑을 교체하지 않고 살펴보기
    def peek(self):
        return self.top.item
    
    def is_empty(self):
        return self.top is None
```





## 4회차 - 9장 큐

> FIFO [ First In First Out ] 자료 구조로 먼저 들어간 순서대로 나온다
>
> Ex) 놀이공원 줄, 순차적인 처리

![Queue_structure](md-images/Queue_structure.png)

### Deque [ Double-ended-queue ]

> 원형 큐이다
>
> deque는 append와 appendleft, pop과 popleft가 모두 빠르고 간결해서 queue는 deque를 사용한다



![Deque_structure](md-images/Deque_structure.png)

### 원형 큐 [ Circular Queue ] - 큐의 한계

> 원형큐가 필요한 이유
>
> 큐는 메모리를 할당 한 후 사용하기 때문에, pop에 의해 앞의 메모리에 공간이 남아있어도
> 앞의 메모리 공간에 push할 수 없다
> 원형 큐를 사용하면 순환이 되므로 빈 앞공간을 활용 할 수 있다



```python
class Node:
    def __init__(self, value, next):
        self.value = value
        self.next = next

class Queue:
    def __init__(self):
        self.front = None

    def push(self, value):
        if not self.front:
            self.front = Node(value, None)
            return
        
        ## 제일 끝까지 간 다음 넣어줘야 함
        node = self.front
        while node.next:
            node = node.next
        node.next = Node(value, None)

    def pop(self):
        if not self.front:
            return None

        node = self.front
        self.front = self.front.next
        return node.value
    
    def peek(self):
        return self.front.value

    def is_empty(self):
        return self.front is None
```









## 5회차 - 11장 해시 테이블

## 6회차 - 12장 그래프 + DFS



126페이지까지 작성

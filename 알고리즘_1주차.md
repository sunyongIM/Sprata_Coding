> <파이썬 알고리즘 인터뷰> [책만]
>
> [[스파르타코딩클럽\] 파이썬 문법 뽀개기 (notion.so)](https://www.notion.so/dfb89a042c6f4b29b64ea4da03a37ea6#9e45965f552e4768b295f003bc5a3436)

# 1주차

## 1회차 - 알고리즘 개요

> [1회차 알고리즘 개요 (notion.site)](https://teamsparta.notion.site/1-eed263c144bf4d9fb9866cc668c1b977)

- 문제

  <aside> ❓ Q. 다음과 같이 숫자로 이루어진 배열이 있을 때, 이 배열 내에서 가장 큰 수를 반환하시오.</aside>

  ```python
  [3, 5, 6, 1, 2, 4]
  ```

- 생각해보기

  - 1억 개라면?

    - 시간복잡도를 낮추는 알고리즘을 이용
      - **반복문 중첩이 적을수록 좋다!!**

  - 메모장이 작다면?

    - 공간복잡도를 낮추는 알고리즘을 이용

      - 메모리 공간을 적게 쓸수록 좋다

      > (공간복잡도는 C언어나 임베디드쪽이 아니면 크게 신경 안써도 됨)



- 최빈값 찾기

  - Q. 문제 설명

    <aside> ❓ Q.  다음과 같은 문자열을 입력받았을 때, 어떤 알파벳이 가장 많이 포함되어 있는지 반환하시오</aside>

    ```python
    "hello my name is sparta"
    ```

  - Answer

```python
import string
## pprint - prety print 더 예쁘게 출력됨
from pprint import pprint

text = 'hello, this is sparta'

counter = {}
# 21 번 연산
for char in text:
    if not char.isalpha():
        continue
    if char in counter:
        counter[char] += 1
    else:
        counter[char] = 1
pprint(counter)
```

### 점근 표기법

> 알고리즘의 성능을 수학적으로 표기하는 방법입니다. 알고리즘의 “효율성”을 평가하는 방법입니다.

```HTML
점근 표기법의 종류에는 
빅오(Big-O)표기법, 빅오메가(Big-Ω) 표기법이 있습니다.

빅오 표기법은 최악의 성능이 나올 때 어느 정도의 연산량이 걸릴것인지,
빅오메가 표기법은 최선의 성능이 나올 때 어느 정도의 연산량이 걸릴것인지에 대해 표기합니다.

예를 들어 
빅오 표기법으로 표시하면 $O(N)$,
빅 오메가 표기법으로 표시하면 $Ω(1)$ 의 시간복잡도를 가진 알고리즘이다
```

> (빅 오메가 거의 안씀)



### 빅오(O)

> 빅오 표기법은 주어진(최선/최악/평균) 경우의 수행 시간의 **상한**을 나타낸다
>
> 특히 가장 늦게 실행될 때를 **빅오(O)**라고 한다 **(최악의 경우의 상한)**



### 분할 상환 분석

> 시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때, 알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적이라는 이유로 생겨났다
>
> 최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산할 수 있다
> 유용함 덕분에 최근에는 시간 복잡도를 계산할 때 매우 보편적으로 널리 사용된다



### 병렬화

> 일부 알고리즘들은 병렬화로 실행 속도를 높일 수 있다
>
> GPU가 병렬 연산을 위한 대표적인 장치이다
> GPU의 각각의 코어는 CPU의 코어보다 느리지만, 개수가 많기 때문에 GPU를 사용하여 병렬연산을 할 수 있는 알고리즘은 속도가 빠르고 우수하다고 평가받는다







### 문제) 알파벳 찾기

> [10809번: 알파벳 찾기 (acmicpc.net)](https://www.acmicpc.net/problem/10809)

- `ord()` - 문자를 아스키 코드로 바꿔줌
  - ord(a) => 97
- `chr()` - 아스키 코드를 문자로 바꿔줌
  - chr(97) => a
- `string.ascii_lowercase` - a~z까지 26개의 알파벳 반환
  - `len(string.ascii_lowercase)`으로 26을 구할 수 있다 (불필요하다 생각해서 쓰지않았다)

```python
#내 풀이
def find(word):
    result = [-1]*26
    for i in range(len(word)):
        char = word[i]
        num = ord(char)
        if result[num-97]==-1:
            result[num-97] = i
    #print(result)
    #int를 char로 바꾸고 공백(' ')을 추가해서 프린트
    print(' '.join([str(num) for num in result]))

find('baekjoon')
```

> 접근
>
> 1. 어떤 알파벳이 단어에 포함되지 않는다면 -1을 출력하므로 default값이 [-1]*26 배열
> 2. 주어진 word의 char만 확인하고 그것을 배열에 적용시킨다
> 3. 알파벳은 `ascii code`에서 하나씩 커진다
> 4. 배열의 시작인 a의 `ascii code`가 97이므로 배열의 알파벳과 ord(char)-97 인덱스가 매칭된다
> 5. 한번만 넣어야 하므로 if문으로 해당 위치의 값이 -1인지 확인한다
> 6. 해당 인덱스에 word의 인덱스 i값을 넣는다



### 동적배열

> 크기가 고정되지 않은 배열
>
> 파이썬 리스트의 가장 좋음 점은 매우 다양한 기능을 제공한다는 점이다
> 리스트를 사용하면 사실상 스택을 사용할지, 큐를 사용할지를 고민하지 않아도 되며,
> 스택과 큐에서 사용 가능한 모든 연산을 함께 제공한다

#### 시간복잡도

빅오가 O(1)인 기능

- `len(리스트)`
  - 전체 요소의 개수 리턴 
- `a[i]`
  - 인덱스 i의 요소 가져오기 
- `.append()`
  - 리스트 마지막에 요소 추가 
- `.pop()`
  - 리스트 마지막 요소 추출 

빅오가 O(n)인 기능

- `ele in 리스트`
  - ele 요소 존재여부 확인
- `.count(ele)`
  - ele 요소의 개수를 리턴
- `.index(ele)`
  -  ele 요소의 인덱스를 리턴한다
- `.pop(0)`
  - 첫 번째 요소를 추출 
- `del 리스트[i]`
  - i 인덱스의 값 삭제
- `min(리스트)`,`max(리스트)`
  - 최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다
- `리스트.reverse()`
  - 뒤집는다

빅오가 O(nlogn)인 기능

- `.sort`
  - 정렬한다



> https://wayhome25.github.io/python/2017/06/14/time-complexity/

#### list

| Operation     | Example         | Big-O      | Notes                     |
| :------------ | :-------------- | :--------- | :------------------------ |
| Index         | l[i]            | O(1)       |                           |
| Store         | l[i] = 0        | O(1)       |                           |
| Length        | len(l)          | O(1)       |                           |
| Append        | l.append(5)     | O(1)       |                           |
| Pop           | l.pop()         | O(1)       | l.pop(-1) 과 동일         |
| Clear         | l.clear()       | O(1)       | l = [] 과 유사            |
| Slice         | l[a:b]          | O(b-a)     | l[:] : O(len(l)-0) = O(N) |
| Extend        | l.extend(…)     | O(len(…))  | 확장 길이에 따라          |
| Construction  | list(…)         | O(len(…))  | 요소 길이에 따라          |
| check ==, !=  | l1 == l2        | O(N)       | 비교                      |
| Insert        | ㅣ.insert(i, v) | O(N)       | i 위치에 v를 추가         |
| Delete        | del l[i]        | O(N)       |                           |
| Remove        | l.remove(…)     | O(N)       |                           |
| Containment   | x in/not in l   | O(N)       | 검색                      |
| Copy          | l.copy()        | O(N)       | l[:] 과 동일 - O(N)       |
| Pop           | l.pop(i)        | O(N)       | l.pop(0):O(N)             |
| Extreme value | min(l)/max(l)   | O(N)       | 검색                      |
| Reverse       | l.reverse()     | O(N)       | 그대로 반대로             |
| Iteration     | for v in l:     | O(N)       |                           |
| Sort          | l.sort()        | O(N Log N) |                           |
| Multiply      | k*l             | O(k N)     | [1,2,3] * 3 » O(N**2)     |

#### Dict

| Operation      | Example     | Big-O     | Notes                   |
| :------------- | :---------- | :-------- | :---------------------- |
| Index          | d[k]        | O(1)      |                         |
| Store          | d[k] = v    | O(1)      |                         |
| Length         | len(d)      | O(1)      |                         |
| Delete         | del d[k]    | O(1)      |                         |
| get/setdefault | d.method    | O(1)      |                         |
| Pop            | d.pop(k)    | O(1)      |                         |
| Pop item       | d.popitem() | O(1)      |                         |
| Clear          | d.clear()   | O(1)      | s = {} or = dict() 유사 |
| View           | d.keys()    | O(1)      | d.values() 동일         |
| Construction   | dict(…)     | O(len(…)) |                         |
| Iteration      | for k in d: | O(N)      |                         |



#### 슬라이싱 **`[start:end:step]`**

> 파이썬 리스트에는 슬라이싱 [ slicing ] 기능이 있다
> 원래는 문자열에 활용되는 기능이고 간결하고 강력하다
> **따라서 문자열에서 슬라이싱은 활용할 수 있으면 무조건 하는게 좋다**
>
> b>a일때 `리스트 또는 문자열`[a:b] 로 슬라이싱을 한다면 슬라이싱 된 값의 개수는 **b-a-1개**이다
> 이것은 **인덱스 b의 값이 슬라이싱 된 값에 포함되지 않기** 때문에 발생된다
> 자주 헷갈리니 조심해야 한다

##### 리스트+문자열

- 리스트와 문자열에서 <인덱스 1에서 인덱스 3 **이전**까지 값을 가져오기>
  - `리스트[1:3]`
  - `문자열[1:3]`

> 세번째 파라미터(step) 활용 - step만큼 건너뛰기

- 인덱스1에서 10이전까지 홀수번째 (**step씩 건너**뛰어) 인덱스의 값을 가져오기
  - `리스트[1:10:2]`

**문자열만 가능**

- 뒤집기
  - `리스트[::-1]`



#### delete, remove, pop

> delete - index로 삭제하기, remove - 값으로 삭제하기, pop - 값 반환 + 삭제

- `del 리스트[i]`
  - index가 i인 값을 삭제한다
- `리스트.remove(값)`
  - 값에 해당하는 요소 삭제
- `리스트.pop(i)`
  - index가 i인 값을 삭제하고 반환



#### .join()

> **''.join(리스트)**
>
> **'구분자'.join(리스트)**

- 리스트를 문자열로 만들어주는 기능
- 구분자가 있는 경우 문자열 사이에 구분자가 들어간다
- **`''.join(리스트)`** <== 많이쓴다



#### sorted()

- `sorted(문자열)`
  - 문자열의 **정렬 결과를 list로 리턴**
  - list타입 정렬 결과를 다시 조립할 때 `''.join(리스트)` 사용
- `sorted(리스트)`
  - 리스트를 **정렬해 list로 리턴**

#### .sort()

> sorted()와는 다르게 sort()는 **리스트 자체를 제자리 정렬**하기에 리턴값이 없다

- `리스트.sort()`
  - 리스트 자체를 정렬하여 정렬된 값으로 덮어씌운다



#### 정렬방법

> sort()와 sorted() 모두 `key=len`과 같이 key= 로 정렬 옵션을 지정해 줄 수 있다



### 파이썬 토막 문법1

```python
def funName(x: str, y: float = 6.5) -> int:		##type hinting
    return x + y

value = funName(3)
print(value)
```

> **함수명 : def 다음에 나와있는 funName**
>
> **`x : str` - 콜론(:) 다음에 적어주는 것은 매개변수에 할당되는 형식을 말한다.**
>
> **`y : float = 6.5` - 초기값을 콜론다음에 해당 형식 뒤에 = 하고 값을 적어줄 수 있다. (변수 : 형식 = 기본값)**
>
> **`-> int :` - 이 함수가 반환해주는 값의 형식이 int라는 것을 말한다!** (type hinting)



#### if문 - 삼항연산자

```python
num = 3

```



#### ***self 이해하기

> https://wikidocs.net/1742
>
> 파이썬 메서드의 첫 번째 인자로 항상 인스턴스가 전달되기 때문에 발생하는 문제
> self가 인자로 있는 메소드는 인스턴스를 이용할 수 있고
> self가 인자로 없는 메소드는 클래스 자체를 이용해야한다

```python
class example:
    def test1(this, arg:int) -> str:
        return f'테스트1 {arg}'
    def test2(arg:int) -> str:
        return f'테스트2 {arg}'


result1 = example()
print(result1.test1(arg=12))
#### this인자가 있는 메소드를 사용할 땐 객체 result1을 class로 인스턴스화 시켜 사용한다

result2 = example.test2(arg=54)
print(result2)
#### this인자가 없는 메소드는 인스턴스를 통해 호출할 수 없는 대신 파이썬의 클래스는
#### 그 자체가 하나의 네임스페이스이기 때문에, 인스턴스 생성과 관계없이 클래스 내의 메서드를 직접 호출할 수 있다

## 에러코드 ##
# result1 = example.test1(arg=12)		# self 위치에 (인스턴스)인자를 전달해야함

# result2 = example()
# print(result2.test2(arg=54))		# self 파라미터가 없는데 (인스턴스)인자가 전달됨
```





## 2회차 - 8장 연결 리스트

## 3회차 - 9장 스택

## 4회차 - 9장 큐

## 5회차 - 11장 해시 테이블

## 6회차 - 12장 그래프 + DFS



126페이지까지 작성
